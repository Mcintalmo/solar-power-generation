library(tidyverse)
library(lubridate)
library(hms)
library(broom)
library(forecast)
library(fable) # Requires installing "feasts" package
library(ranger)
library(randomForest)
library(pls)
library(caret)


###QUESTIONS TO POSSIBLE ASK:
# *** Can we predict the power generation for next couple of days? - this allows for better grid management
# Can we identify the need for panel cleaning/maintenance?
# Can we identify faulty or suboptimally performing equipment?
  

################################################################################
# EXTRACT, TRANSFORM, LOAD
################################################################################

#Sources
#Power generation and sensor data gathered from two solar power plants

#Collection Methodology
#Power generation and sensor data gathered at 15 minutes intervals over a 34 day
#period. Generation data collected at inverter level, while the sensor data is at
#the plant level.

# This data has been gathered at two solar power plants in India over a 34 day 
# period. It has two pairs of files - each pair has one power generation 
# dataset and one sensor readings dataset. The power generation datasets are 
# gathered at the inverter level - each inverter has multiple lines of solar 
# panels attached to it. The sensor data is gathered at a plant level - single 

# Plant 1 is near Gandikotta, Andhra and Plant 2 is near Nasik, Maharashtra.

# array of sensors optimally placed at the plant.

# DATE_TIME: Date and time for each observation. Observations recorded at 15 minute intervals.
# Generation - SOURCE_KEY: In generation file stands for the inverter id.
# Weather - SOURCE_KEY: Stands for the sensor panel id. This will be common for the entire file because there's only one sensor panel for the plant.
# DC_POWER: Amount of DC power generated by the inverter (source_key) in this 15 minute interval. Units - kW.
# AC_POWER: Amount of AC power generated by the inverter (source_key) in this 15 minute interval. Units - kW.
# DAILY_YIELD: A cumulative sum of power generated on that day, till that point in time.
# TOTAL_YIELD: The total yield for the inverter till that point in time.
# AMBIENT_TEMPERATURE: This is the ambient temperature at the plant.
# MODULE_TEMPERATURE: There's a module (solar panel) attached to the sensor panel. This is the temperature reading for that module.
# IRRADIATION: Amount of irradiation for the 15 minute interval.

parse_generation_data <- function(file_name,
                                  date_format = "ymd HM",
                                  data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    # For some reason, the two files use different date formatting
    mutate(date_time = parse_date_time(DATE_TIME, date_format),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           dc_power = DC_POWER,
           ac_power = AC_POWER,
           daily_yield = DAILY_YIELD,
           total_yield = TOTAL_YIELD) %>%
    relocate(date_time,
             plant_id,
             source_key,
             dc_power,
             ac_power,
             daily_yield,
             total_yield)
}


parse_weather_data <- function(file_name, data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    mutate(date_time = parse_date_time(DATE_TIME, ("ymd HMS")),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           ambient_temperature = AMBIENT_TEMPERATURE,
           module_temperature = MODULE_TEMPERATURE,
           irradiation = IRRADIATION) %>%
    relocate(date_time,
             plant_id,
             source_key,
             ambient_temperature,
             module_temperature,
             irradiation)
}


generation <- 
  parse_generation_data("Plant_1_Generation_Data.csv", "dmy HM") %>%
  bind_rows(parse_generation_data("Plant_2_Generation_Data.csv", "ymd HMS"))


weather <- parse_weather_data("Plant_1_Weather_Sensor_Data.csv") %>%
  bind_rows(parse_weather_data("Plant_2_Weather_Sensor_Data.csv"))


################################################################################
######################### SEPARATE VALIDATION ##################################
################################################################################
head(generation)
dim(generation) # 136476    7
head(weather)
dim(weather) # 6441    6

# Before we go any further, Let's determine the validation set. 
range(generation$date_time)
difftime(max(generation$date_time), min(generation$date_time))
#We have data for 34 days. Let's take about
#  10% of the data, and treat the last 4 days as validation.

extract_validation <- function(data, date_time_cutoff = make_date(2020, 06, 14)){
  data %>%
    filter(date_time >= date_time_cutoff)
}

validation_generation <- generation %>%
  extract_validation()

validation_weather <- weather %>%
  extract_validation()

generation <- generation %>%
  anti_join(validation_generation)

weather <- weather %>%
  anti_join(validation_weather)

nrow(generation) # 119624
nrow(validation_generation) # 16852

nrow(weather) # 5673
nrow(validation_weather)

rm(extract_validation) # 768

#### METRIC OF IMPROVEMENT ####
RMSE <- function(predicted_power, test_power){
  sqrt(mean((test_power - predicted_power) ^ 2, na.rm = TRUE))
}

################################################################################
############################ DATA CLEANING #####################################
################################################################################
# Before we combine the data, let's do a quick sanity check. Full disclosure,
#  I discovered this quirk much later in analysis. I moved it here to to
#  reduce lines of code and make future graphs more intuitive.

plant_ids <- generation %>%
  distinct(plant_id) %>%
  pull(plant_id)

# Let's take a quick look at the stats for generation
generation %>% 
  group_by(plant_id) %>%
  summarize(min = min(dc_power),
            max = max(dc_power),
            median = median(dc_power),
            mean = mean(dc_power))

# Hmm. The max and median are off by almost a factor of 10.
generation %>%
  group_by(plant_id) %>%
  ggplot(aes(x = dc_power, fill = plant_id))+
  geom_histogram() +
  labs(title = "DC Power Distribution by Plant",
       x = "DC Power",
       y = "Count")

# Waoh, something is definitely off. Let us assume that there was a conversion
#  error. Considering that the date formats were different accross files, it is
#  not unlikely that units were recorded differently. To confirm, let's look at
#  the ac power output based on dc power generated. We expect a line
#  approximately on the unity, with slight loss.

generation %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point() +
  geom_abline(size = 1) +
  labs(title = "DC to AC Power Conversion",
       x = "DC Power",
       y = "AC Power",
       color = "Plant ID")

# This suggests that somehow the power output is 10 times the input. As this is
#  impossible, suggesting input error. As the date formats between the two plants
#  is different, human error is not impossible.

# A 90% loss rate is incredibly high. Considering a comparable AC power output,
#  it is far more likely to be a unit conversion problem. To fix is:

generation %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point() +
  geom_abline(size = 1) +
  labs(title = "DC to AC Power Conversion",
       x = "DC Power",
       y = "AC Power",
       color = "Plant ID")

# This more closely aligns with expectation.

# Before moving forward, a quick function will be written to relate the
#  generation and weather data, as that will be common.
join_generation_weather <- function(generation_data, weather_data) {
  generation_data %>%
    group_by(plant_id) %>%
    expand(date_time = full_seq(date_time, as.numeric(minutes(15))), # include a time stamp for every generation source for every 15 minutes
           generation_source = source_key) %>% # rename necessary since weather also has a source_key
    ungroup() %>%
    left_join(generation_data, by = c("date_time", # Add in rows that have been observed
                                      "plant_id", 
                                      "generation_source" = "source_key")) %>% # Rename duplicated variable name
    full_join(weather_data, by = c("date_time", "plant_id")) %>% # Add weather data
    rename(weather_source = source_key) # Rename duplicated variable name
}

solar <- join_generation_weather(generation, weather)
head(solar)
dim(solar) # 126720     11
# Discrepency in row counts has to do with missing rows from generation data

## The noise present in plant 2, seemingly as a result of faulty panels, 
# makes prediction difficult without first developing an outlier detection
# method. Since the scope of this project encapsulates predictions, we will
# REMOVE the problem sources. Plant 2 seems to be a problem. Can we be more
# precise?

solar %>%
  na.omit() %>%
  filter((dc_power == 0 & irradiation > 0)) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  labs(title = "Sensor Failures and Anomalies Over Time",
       x = "Time", 
       y = "Anamoly Count")

solar %>%
  anti_join(generation) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(generation$date_time)) +
  labs(title = "Time Series of Power Inverter Failures",
       x = "Time",
       y = "Number of Failures")

solar %>%
  select(date_time, plant_id) %>%
  unique() %>%
  anti_join(weather) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(weather$date_time)) +
  labs(title = "Time Series of Weather Sensor Failures",
       x = "Time",
       y = "Number of Failures")


solar %>%
  group_by(plant_id, generation_source) %>%  
  filter((dc_power == 0 & irradiation > 0) | is.na(dc_power)) %>%
  tally() %>%
  arrange(desc(n)) %>%
  ggplot(aes(x = reorder(generation_source, -n), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Anamolies and Failures by Source",
       x = "Generation Sensor Key",
       y = "Anamoly Count")

solar %>%
  na.omit() %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum((dc_power == 0 & irradiation > 0))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Anomaly Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum(is.na(dc_power) | is.na(irradiation))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Failure Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  mutate(is_na = is.na(dc_power) | is.na(irradiation)) %>%
  mutate(likely_na = !is_na & dc_power == 0 & irradiation > 0) %>%
  summarize(na_rate = sum(is_na), likely_na_rate = sum(likely_na)) %>%
  ggplot(aes(x = na_rate, y = likely_na_rate, color = plant_id)) +
  geom_point() +
  labs(title = "Relationship Between Sensor NA and Anamoly",
       x = "NA Count",
       y = "Anamoly County")


# Meaning most of the anamolies are in fact garbage data. Not knowing the cause of
#  the failures and requiring additional analysis to tease out correlations,
#  we will work only with plant 4135001 moving forward
solar <- solar %>%
  filter(plant_id == "4135001")

nrow(solar) # 63360

object.size(generation)
object.size(weather)
object.size(solar)
object.size(validation_generation)
object.size(validation_weather)

rm(parse_generation_data, parse_weather_data)

################################################################################
############################### EXPLORATION ####################################
################################################################################

#### DATE_TIME ####
n_distinct(solar$date_time) # 2880


#### SOURCE_KEY ####
n_distinct(generation$source_key) # 44
n_distinct(weather$source_key) # 2

plant_1_source_keys <- 
  generation %>%
  filter(plant_id == "4135001") %>%
  pull(source_key) %>%
  unique()

plant_2_source_keys <- 
  generation %>%
  filter(plant_id == "4136001") %>%
  pull(source_key) %>%
  unique()

intersect(plant_1_source_keys, plant_2_source_keys) # character(0)

rm(plant_1_source_keys, plant_2_source_keys)


################################################################################
######################     Generation Data      ################################
################################################################################

# DC Power
generation %>% 
  group_by(plant_id) %>%
  summarize(min = min(dc_power),
            max = max(dc_power),
            median = median(dc_power),
            mean = mean(dc_power))

generation %>%
  ggplot(aes(x = dc_power, fill = plant_id))+
  geom_histogram()

generation %>%
  filter(dc_power > 0.0) %>%
  ggplot(aes(x = dc_power, fill = plant_id)) +
  geom_histogram()

generation %>%
  group_by(plant_id) %>%
  summarize(no_dc_rate = mean(dc_power == 0)) # 0.495


# AC Power
generation %>%
  group_by(plant_id) %>%
  summarize(min = min(ac_power),
            max = max(ac_power),
            median = median(ac_power),
            mean = mean(ac_power))

generation %>%
  ggplot(aes(x = ac_power, fill = plant_id)) +
  geom_histogram()

generation %>%
  filter(ac_power > 0.0) %>%
  ggplot(aes(x = ac_power, fill = plant_id))+
  geom_histogram()

generation %>%
  group_by(plant_id) %>%
  summarize(no_ac_rate = mean(ac_power == 0)) # 0.495


# Daily Yield
generation %>% 
  group_by(plant_id) %>%
  summarize(min = min(daily_yield),
            max = max(daily_yield),
            median = median(daily_yield),
            mean = mean(daily_yield))

generation %>%
  ggplot(aes(x = daily_yield, fill = plant_id)) +
  geom_histogram()

generation %>%
  filter(daily_yield > 0.0) %>%
  ggplot(aes(x = daily_yield, fill = plant_id)) +
  geom_histogram()

generation %>%
  group_by(plant_id) %>%
  summarize(no_daily_yield_rate = mean(daily_yield == 0)) # 0.222

# Total Yield
generation %>% 
  group_by(plant_id) %>%
  summarize(min = min(total_yield),
            max = max(total_yield),
            median = median(total_yield),
            mean = mean(total_yield))

generation %>%
  ggplot(aes(x = total_yield, fill = plant_id))+
  geom_histogram()

generation %>%
  filter(total_yield > 0.3) %>%
  ggplot(aes(x = total_yield, fill = plant_id))+
  geom_histogram() +
  scale_x_log10()

generation %>%
  summarize(no_total_yield_rate = mean(total_yield == 0)) # 0.00413

################################################################################
################################### Averages ###################################
################################################################################
# view one day from one source
generation %>%
  filter(source_key == unique(source_key)[1]) %>%
  filter(date_time < make_date(2020, 05, 16)) %>%
  ggplot(aes(x = date_time, y = dc_power)) +
  geom_line()

# view all sources for one day
generation %>%
  filter(date_time < make_date(2020, 05, 16)) %>%
  group_by(date_time, plant_id) %>%
  summarize(avg_dc_power = mean(dc_power)) %>%
  group_by(plant_id) %>%
  ggplot(aes(x = date_time, y = avg_dc_power, color = plant_id)) +
  geom_line() +
  theme(legend.position = "none")

# Note: This graph crashes R when produced as a stacked area
# View entire month average by plant
generation %>%
  group_by(date_time, plant_id) %>%
  summarize(avg_dc_power = mean(dc_power)) %>%
  group_by(plant_id) %>%
  ggplot(aes(x = date_time, y = avg_dc_power, color = plant_id)) +
  geom_line()
################################################################################
######################       Weather Data     ##################################
################################################################################

# Ambient Temperature
weather %>%
  group_by(plant_id) %>%
  summarize(min = min(ambient_temperature),
            max = max(ambient_temperature),
            median = median(ambient_temperature),
            mean = mean(ambient_temperature))

weather %>%
  ggplot(aes(x = ambient_temperature, fill = plant_id)) +
  geom_histogram(bins = 40)

# Module Temperature
weather %>%
  group_by(plant_id) %>%
  summarize(min = min(module_temperature),
            max = max(module_temperature),
            median = median(module_temperature),
            mean = mean(module_temperature))

weather %>%
  ggplot(aes(x = module_temperature, fill = plant_id)) +
  geom_histogram(bins = 40)

# Irradiation
weather %>%
  group_by(plant_id) %>%
  summarize(min = min(irradiation),
            max = max(irradiation),
            median = median(irradiation),
            mean = mean(irradiation))

weather %>%
  ggplot(aes(x = irradiation, fill = plant_id)) +
  geom_histogram(bins = 40)

weather %>%
  filter(irradiation > 0.00001) %>%
  ggplot(aes(x = irradiation, fill = plant_id)) +
  geom_histogram(bins = 40)

weather %>%
  summarize(no_irradiation_rate = mean(irradiation == 0)) # 0.438

################################################################################
################################### Plots ###################################
################################################################################

# Daily Irradiation for plant 1
weather %>%
  filter(plant_id == plant_ids[1]) %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = irradiation, group = date, color = date)) +
  geom_line(alpha = 0.5)

# Daily Irradiation for plant 2
weather %>%
  filter(plant_id == plant_ids[2]) %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = irradiation, group = date, color = date)) +
  geom_line(alpha = 0.5)

# view entire month from both sources
weather %>%
  group_by(plant_id) %>%
  ggplot(aes(x = date_time, y = irradiation, color = plant_id)) +
  geom_line() +
  geom_smooth()

weather %>%
  group_by(plant_id) %>%
  ggplot(aes(x = date_time, y = ambient_temperature, color = plant_id)) +
  geom_line() + 
  geom_smooth()

weather %>%
  group_by(plant_id) %>%
  ggplot(aes(x = date_time, y = module_temperature, color = plant_id)) +
  geom_line() +
  geom_smooth()


################################################################################
############################ REGRESSION ANALYSIS ###############################
################################################################################
solar %>%
  na.omit() %>%
  select(dc_power, ac_power) %>%
  cor() %>%
  .[1, 2]

#### AC Power vs DC Power ####

solar %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point(alpha = 0.25) +
  geom_abline()

fit <- solar %>%
  lm(ac_power ~ dc_power, data = .)


solar %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point(alpha = 0.25) +
  geom_abline(slope = fit$coefficients[2], 
              intercept = fit$coefficients[1],
              size = 1) +
  labs(title = "AC Power Produced per DC Power In",
       x = "DC Power",
       y = "AC Power")


#### IRRADIATION TO TEMPERATURE ####

# Relationship between module temperature and ambient temperature
solar %>%
  mutate(time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  ggplot(aes(x = ambient_temperature, y = module_temperature, color = time)) +
  geom_point()

solar %>%
  mutate(time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  summarize(avg_amb_temp = mean(ambient_temperature, na.rm = TRUE),
            avg_mod_temp = mean(module_temperature, na.rm = TRUE)) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = avg_amb_temp, color = "Average Ambient Temperature")) +
  geom_line(aes(y = avg_mod_temp, color = "Average Module Temperature"))
### !! Ambient temperature -lags- module temperature, suggesting if anything
###  causality would be that high module temperature is affecting ambient temp reading

# Relationship between irradiation and module temperature
solar %>%
  mutate(time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  ggplot(aes(x = irradiation, y = module_temperature, color = time)) +
  geom_point() 

solar %>%
  mutate(time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  summarize(avg_irradiation = 20 + 40 *  mean(irradiation, na.rm = TRUE),
            avg_mod_temp = mean(module_temperature, na.rm = TRUE)) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = avg_irradiation, color = "Average Irradiation (+20, x40)")) +
  geom_line(aes(y = avg_mod_temp, color = "Average Module Temperature"))
### Irradiation leads ambient temperature by 15 minutes to a half an hour


### Relationship between irradiation and ambient temperature
solar %>%
  mutate(time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  ggplot(aes(x = irradiation, y = ambient_temperature, color = time)) +
  geom_point()

############ LAG in the weather
acf <- ccf(weather$module_temperature,
           weather$irradiation,
           na.action = na.pass,
           lag.max = 48)

tibble(lag = c(acf$lag),
       acf = c(acf$acf)) %>%
  slice_max(acf)

#Confirmed lag of 15 minutes between irradiation and module temperature

acf <- ccf(weather$ambient_temperature,
           weather$irradiation,
           na.action = na.pass,
           lag.max = 48)

tibble(lag = c(acf$lag),
       acf = c(acf$acf)) %>%
  slice_max(acf)

# Lag of 2 hours, 15 minutes between irradiation and ambient temperature


acf <- ccf(weather$ambient_temperature,
           weather$module_temperature,
           na.action = na.pass,
           lag.max = 48)

tibble(lag = c(acf$lag),
       acf = c(acf$acf)) %>%
  slice_max(acf)

# Lag of 1 hour, 30 minutes between ambient temperature and module temperature


acf <- ccf(solar %>% pull(dc_power),
           solar %>% pull(irradiation),
           na.action = na.pass,
           lag.max = 25)

tibble(lag = c(acf$lag),
       acf = c(acf$acf)) %>%
  slice_max(acf)


### FROM THIS: I am going to conclude that temperature is highly  correlated
### to irradiation and time. 
### AC is directly correlated to DC. 
# Let's start building our model based on: 
# 1) irradiation
# 2) module temperature
# 3) ambient temperature
# 4) time

set.seed(1)
# test_index <- solar %>%
#   na.omit() %>%
#   pull(dc_power) %>%
#   createDataPartition(times = 1, p = 0.2, list = FALSE)
# 
# train_set <- solar %>% 
#   na.omit() %>% 
#   slice(- test_index)
# 
# test_set <- solar %>%
#   na.omit() %>% 
#   slice(test_index)

test_set <- solar %>%
  filter(date_time > make_date(2020, 06, 12))

train_set <- solar %>%
  anti_join(test_set)

########    NAIVE RMSE    ####
mu_hat <- mean(train_set$dc_power, na.rm = TRUE) # 321.0874
naive_rmse <- RMSE(mu_hat, test_set$dc_power) # 401.8058
results <- tibble(method = "Average", RMSE = naive_rmse)


########### IRRADIATION
fit <- lm(dc_power ~ irradiation, data = train_set)

train_set %>%
  ggplot(aes(irradiation, dc_power, color = plant_id)) +
  geom_point(alpha = 0.1) +
  geom_abline(slope = fit$coefficients[2],
              intercept = fit$coefficients[1],
              size = 1)
  
predicted_power <- predict(fit, newdata = test_set)

irradiation_rmse <- RMSE(predicted_power, test_set$dc_power) # 583.1007
results <- results %>%
  add_row(method = "Irradiation Effect", RMSE = irradiation_rmse)


################## Temperature effect
train_set %>%
  mutate(dc_power_resid = dc_power - irradiation * fit$coefficients[2] - fit$coefficients[1]) %>%
  group_by(plant_id) %>%
  ggplot(aes(module_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "black")

# Suggests an optimal operating temperature between 20 and 54 degrees.
# Module temperature best represented by parabola
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)
irradiation_module_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 40.03656
results <- results %>%
  add_row(method = "Irradiation + Module Temperature", 
          RMSE = irradiation_module_temperature_rmse)

################## Ambient Temperature effect
train_set %>%
  mutate(dc_power_resid = dc_power 
         - fit$coefficients[1] 
         - irradiation * fit$coefficients[2] 
         - module_temperature * fit$coefficients[3]
         - module_temperature ^ 2 * fit$coefficients[4]) %>%
  ggplot(aes(ambient_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.01) +
  geom_smooth(color = "black")
# Negligable


##### Time Effect
  

############### ARIMA:1 Auto-Regressive Integrated Moving Average

y_train <- train_set %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power, na.rm = TRUE)) %>%
  pull(avg_dc_power) %>%
  ts(frequency = 96) # 4 * 24 for every 15 minutes over 24 hours

arima_result <- auto.arima(y = y, seasonal = TRUE)
date_times <- test_set %>%
  pull(date_time) %>%
  unique()
generation_sources <- solar %>%
  pull(generation_source) %>%
  unique()

forecast_result <- forecast(arima_result, h = length(date_times)) %>% 
  plot()
predicted_power <- tibble(date_time = date_times, pred = forecast_result$mean)
predicted_power <- expand_grid(date_time = date_times,
                               generation_source = generation_sources) %>%
  left_join(predicted_power, by = "date_time")

arima_rmse <- RMSE(predicted_power$pred, test_set$dc_power) # 179.0664
results <- results %>%
  add_row(method = "ARIMA", RMSE = arima_rmse)

############ GENERATION SOURCE
train_set %>%
  filter(date_time < make_date(2020, 5, 25) & date_time > make_date(2020, 5, 22)) %>%
  mutate(dc_power_resid = dc_power 
         - fit$coefficients[1] 
         - irradiation * fit$coefficients[2] 
         - module_temperature * fit$coefficients[3]
         - module_temperature ^ 2 * fit$coefficients[4]) %>%
  ggplot(aes(x = date_time, dc_power_resid)) +
  geom_line(alpha = 0.1, aes(color = generation_source)) +
  theme(legend.position = "none")

### AVG by generation_source ::: NEGATIVE EFFECT
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)
predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)
predicted_power <- predicted_power + train_set %>%
  group_by(generation_source) %>%
  summarize(avg_dc_power = mu_hat - mean(dc_power, na.rm = TRUE)) %>%
  right_join(test_set) %>%
  pull(avg_dc_power)
  
RMSE(predicted_power, test_set$dc_power) # 40.05285 WORSE than just lm
  

### AUTO ARIMA by GENERATION SOURCE
ts_train_set <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)
  
arima_models <- ts_train_set %>%
  model(arima = ARIMA(dc_power ~ irradiation + module_temperature + module_temperature_sq))

ts_test_set <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)

predicted_power <- forecast(arima_models, new_data = ts_test_set) %>%
  arrange(date_time) %>%
  pull(.mean)

RMSE(predicted_power, test_set$dc_power) # 40.98546 WORSE THAN THE AVERAGE

######### RANDOM FOREST
train_set_wide <- train_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = as.factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

test_set_wide <- test_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

# fit <- ranger(dc_power ~ .,
#               data = train_set_wide,
#               num.trees = 250,
#               max.depth = 4,
#               probability = TRUE)
# fit <- train(dc_power ~ irradiation, data = train_set_wide, method = "rf", verbose = TRUE)
fit <- randomForest(dc_power ~ .,
             data = train_set_wide,
             xtest = select(test_set_wide, -dc_power),
             ytest = pull(test_set_wide, dc_power),
             na.action = na.omit)



### PCA

train_set_wide <- train_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         intercept = 1) %>%
  pivot_wider(names_from = "generation_source", values_from = intercept, values_fill = 0) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()
# TODO: Binarize generation source data

test_set_wide <- test_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         intercept = 1) %>%
  pivot_wider(names_from = "generation_source", values_from = intercept, values_fill = 0) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

pca <- prcomp(train_set_wide, scale = FALSE)
pca$rotation <- -1 * pca$rotation
pca$rotation

var_explained <- result$sdev ^ 2 / sum(result$sdev ^ 2) # suggests there is 1 big component, 4 smaller ones of about equal impact
qplot(c(1:29), var_explained, xlab = "Principle Component")

summary(pca)


set.seed(1)
fit <- pcr(dc_power ~ ., data = train_set_wide, scale = TRUE, validation = "CV")
summary(fit)
plot(fit)

RMSEs <- sapply(c(1:28), function(n_comp){
  predicted_power<- predict(fit, test_set_wide, ncomp = n_comp)
  RMSE(predicted_power, test_set$dc_power)
})

qplot(c(1:28), RMSEs) +
  geom_line()

RMSEs


########### SENSOR FAULTS
fit <- train_set %>%
  filter(!(irradiation > 0 & dc_power == 0)) %>%
  na.omit() %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(is.na(irradiation) | irradiation == 0 | pred < 0, 0, pred)) %>%
  pull(pred)

all_factors_and_clamp <- RMSE(predicted_power, test_set$dc_power) # 581.7728
results <- results %>%
  add_row(method = "Clamp and Fault Detection", RMSE = all_factors_and_clamp)
  

################################################################################
# Predictions and RMSE
################################################################################
# Use Forecast and Arima to model time series