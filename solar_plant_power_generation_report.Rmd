---
title: "Predicting Solar Power Generation"
author: "Alexander McIntosh"
date: "08/08/2022"
output:
  bookdown::pdf_document2
figsintext : yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, # Default to false considering I hope to use mostly graphs
  message = FALSE,
  warning = FALSE,
  tidy = TRUE,
  cahe = TRUE, # Set to FALSE to conserve memory
  eval = TRUE # Set to TRUE for code to actually rune
)
options(digits = 3)
```

# Introduction {#introduction}

As the unintended consequences of traditional energy collection become untenable,
the world is turning to alternative, renewable energy sources.
Solar power has become a particularly popular method of energy extraction.
However, a notable drawback of solar power is its lack of day-to-day consistency.
Inconsistency is a significant challenge for interfacing with an external power grid.

In the analysis to follow, using only the data collected at the solar power plant,
the power output of the plant will be predicted based only on data available to
the plant.
First, suspicious data are examined for usability.
Then, the clean data are explored for patterns, correlation, and causality. 
Finally, four models are engineered using linear regression, ARIMA, and 
random forest machine learning.
The success of each model was measured by the model's ability to predict three
days worth of data, separated before the models' construction.
The metric for success was the Root Mean Squared Error, or RMSE.
The lower an RMSE value, the better the predictive capabilites of the model.

For brevity and readability, much of the code and many of the data 
transformations used on the data to produce graphs are not included in this report.
For more information about how the graphs and results were generated, see 
<https://www.github.com/mcintalmo/solar-plant-power-generation>. 
The link includes the R Markdown that generated this report and the 
notebook used for exploration.

To explore the raw data, see
*Solar Power Generation Data* from user Ani Kanal on Kaggle. 

<https://www.kaggle.com/datasets/ef9660b4985471a8797501c8970009f36c5b3515213e2676cf40f540f0100e54> 

Or use command 
```
kaggle datasets download -d anikannal/solar-power-generation-data
```

# Methods and Analysis {#methods_and_analysis}

This analysis was conducted entirely within R. 
Packages included tidyverse and broom for data organization and transformation.
Lubridate and hms allowed for time stamp transformation.
Tsibble, forecast, fable, and feasts provided the backbone of analysis of the data as a 
time series and use of the ARIMA model.
Ranger, randomForest, and caret all contributed functions for developing
a machine learning model.
kableExtra and bookdown were used only in the report to generate more aesthetically 
appealing tables and visualizations.

```{r packages}
library(tidyverse)
library(broom)
library(lubridate)
library(hms)
library(tsibble)
library(forecast)
library(feasts)
library(fable) # Requires installing "feasts" package
library(ranger)
library(randomForest)
library(caret)
library(kableExtra)
```
## Data Collection {#data_collection}
The data for this analysis was collected by two solar plants in India.
The first plant, id: 4135001, is near Gandikotta, Andhra and the second plant,
id: 4136001, is near Nasik, Maharashtra.
The data were collected at 15 minute intervals for 34 days.
22 inverter sensors and one weather sensor at each plant brought the total to 46
sensors collecting data. 


The inverter sensors collected the direct current (DC) and alternating current 
(AC) output of the group of solar panels it was monitoring.
Additionally, the inverters tallied the daily yield in DC output from
midnight to midnight and maintained the total yield the sensor had observed.
Total yield increased until a sensor was replaced, at which point it would begin
again at 0.


The weather sensors recorded the ambient temperature, the temperature of the
module, and the irradiation level.
Owing to the sensors' reading of 0 at night, it is assumed any irradiation is
owed entirely to the sun's radiation.

## Data Cleaning {#data_cleaning}

### The Raw Data {#the_raw_data}
The data are spread out over four comma separated files; two power generation 
files and two weather sensor files, one each for each plant. 
First, the data are read into memory, using lubridate to parse the time stamp,
coercing the plant_id to a character, and renaming variables for usability. 
Note, one of the power generation files has a different date format than the 
other three files. 
This suggests human input or conversion was involved in the collection of
the data.

### Loading the Data {#loading_the_data}

```{r}
parse_generation_data <- function(file_name,
                                  date_format = "ymd HM",
                                  data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    # For some reason, the two files use different date formatting
    mutate(date_time = parse_date_time(DATE_TIME, date_format),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           dc_power = DC_POWER,
           ac_power = AC_POWER,
           daily_yield = DAILY_YIELD,
           total_yield = TOTAL_YIELD) %>%
    relocate(date_time,
             plant_id,
             source_key,
             dc_power,
             ac_power,
             daily_yield,
             total_yield)
}

generation <- 
  parse_generation_data("Plant_1_Generation_Data.csv", "dmy HM") %>%
  bind_rows(parse_generation_data("Plant_2_Generation_Data.csv", "ymd HMS"))


parse_weather_data <- function(file_name, data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    mutate(date_time = parse_date_time(DATE_TIME, ("ymd HMS")),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           ambient_temperature = AMBIENT_TEMPERATURE,
           module_temperature = MODULE_TEMPERATURE,
           irradiation = IRRADIATION) %>%
    relocate(date_time,
             plant_id,
             source_key,
             ambient_temperature,
             module_temperature,
             irradiation)
}

weather <- parse_weather_data("Plant_1_Weather_Sensor_Data.csv") %>%
  bind_rows(parse_weather_data("Plant_2_Weather_Sensor_Data.csv"))
```

```{r, eval = FALSE}
generation %>%
  dim() %>%
  as_tibble() %>%
  add_column(dimension = c("Observations", "Variables")) %>%
  pivot_wider(names_from = dimension, values_from = value) %>%
  kable(caption =  "Power Generation Data Dimensions") %>%
  kable_material()
```

```{r}
generation %>% 
  slice_head(n = 5) %>%
  kbl(caption = "First 5 Observations Of Power Generation Data") %>%
  kable_material()
```

```{r power-generation-source-keys}
generation %>%
  select(plant_id, source_key) %>%
  group_by(source_key) %>%
  slice(1) %>%
  pivot_wider(names_from = "plant_id",
              names_prefix = "Plant ID: ",
              values_from = "source_key") %>%
  unnest() %>%
  kbl(caption = "Power Generation Source Keys") %>%
  kable_material()
```

The generation data consist of 136476 observations of 7 variables: The time stamp,
the plant id number, the inverter key, the measured DC power from the panels, 
the measured AC after inversion, the daily yield of power, and the total yield
that the sensor has ever recorded.
Each plant has 22 units measuring the inverter variables, shown in 
table \@ref(tab:power-generation-source-keys)

```{r, eval = FALSE}
weather %>% 
  dim() %>%
  as_tibble() %>%
  add_column(dimension = c("Observations", "Variables")) %>%
  pivot_wider(names_from = dimension, values_from = value) %>%
  kbl(caption = "Weather Data Dimensions") %>%
  kable_material()
```

```{r}
weather %>%
  slice_head(n = 5) %>%
  kbl(caption = "First 5 Observations Of Weather Data") %>%
  kable_material()
```

```{r weather-source-keys}
weather %>%
  select(plant_id, source_key) %>%
  group_by(source_key) %>%
  slice(1) %>%
  pivot_wider(names_from = "plant_id",
              names_prefix = "Plant ID: ",
              values_from = "source_key") %>%
  unnest() %>%
  kbl(caption = "Weather Data Source Keys") %>%
  kable_material()
```

The weather data consist of only 6441 observations of 6 variables: The time stamp
of the observations at 15 minute intervals, the plant id at which the observation
was taken, the weather sensor key (identical across the plant), the ambient
temperature in Celsius, the module temperature in Celsius, and the irradiation.
The difference in the number of observations owes to the number of sensors.
Each plant has only 1 sensor recording weather data, shown in 
table \@ref(tab:weather-source-keys).

```{r}
rm(parse_generation_data, parse_weather_data)
```

### Sanity Check {#sanity_check}

First, let us take a look at a visualization of the generation data by plant.

```{r generation-dc-power, fig.cap = "DC Power Distribution by Plant"}
generation %>%
  group_by(plant_id) %>%
  ggplot(aes(x = dc_power, fill = plant_id))+
  geom_histogram(bins = 20) +
  labs(x = "DC Power",
       y = "Count",
       fill = "Plant ID")
```

Going by figure \@ref(fig:generation-dc-power), it may be seen that the distribution of DC Power observations
is considerably more spread out for plant 4135001 than 4136001.

```{r dc-generation-summary}
generation %>% 
  group_by(plant_id) %>%
  summarize(min_dc = min(dc_power),
            max_dc = max(dc_power),
            median_dc = median(dc_power),
            mean_dc = mean(dc_power),
            sd_dc = sd(dc_power)) %>%
  kbl(caption = "DC Power Summary by Plant") %>%
  kable_material()
```

In table \@ref(tab:dc-generation-summary), it is shown that the max and mean values 
differ by a factor of 10.
Over half of the recorded observations at plant 4136001 are 0. 
A median of 0 is not unreasonable, if we expect the sun to be down for more than
half of the day.

However, these data were collected in May in India, which resides in the
Northern hemisphere. 
It would be expected that the sun is out for more than half of the observations.
To better understand what might be happening, let us compare the DC output of
the solar panels to the AC output after conversion in figure \@ref(fig:dc-ac-plot).

```{r dc-ac-plot, fig.cap = "DC to AC Power Conversion"}
generation %>%
  ggplot(aes(x = dc_power, y = ac_power)) +
  geom_point(aes(color = plant_id)) +
  geom_abline(size = 1) +
  labs(x = "DC Power",
       y = "AC Power",
       color = "Plant ID") +
  geom_text(aes(0, 1000, label = "y = x"))
```

Plant 4136001 is reporting that the conversion rate from DC power to AC power is
about %100. 
However, 4135001 is reporting a 90% loss of power during conversion, despite
collecting 10 times as much power.
Even the worst DC to AC adapters are about 80% effective. 
This suggests that a conversion error changed the DC Power variable from 
plant 4135001 by a factor of 10.
The conversion error is assumed for the remainder of the analysis, and the 
DC power values for plant 4135001 are divided by 10.

### Missing Observations {#missing_observations}

As noted previously, there were 136,476 power generation observations made.
However, if an observation is made every 15 minutes at 44 sensors for 34 days,
we expect to see 143,616 observations. 

The remaining 7,140 observations are missing, and will be considered NA for time series analysis.
Can a pattern to the missing values be found?
To start, we will fill in the missing time values and combine the weather 
data.

```{r}
join_generation_weather <- function(generation_data, weather_data) {
  generation_data %>%
    group_by(plant_id) %>%
    expand(date_time = full_seq(date_time, as.numeric(minutes(15))), # include a time stamp for every generation source for every 15 minutes
           generation_source = source_key) %>% # rename necessary since weather also has a source_key
    ungroup() %>%
    left_join(generation_data, by = c("date_time", # Add in rows that have been observed
                                 "plant_id", 
                                 "generation_source" = "source_key")) %>% # Rename duplicated variable name
    full_join(weather_data, by = c("date_time", "plant_id")) %>% # Add weather data
    rename(weather_source = source_key) # Rename duplicated variable name
}
```


```{r}
solar <- join_generation_weather(generation, weather)
solar %>%
  slice_head(n = 5) %>%
  kbl(caption = "First 5 Observations in Solar Data") %>%
  kable_material()
```


```{r}
solar %>%
  dim() %>%
  as_tibble() %>%
  add_column(dimension = c("Observations", "Variables")) %>%
  pivot_wider(names_from = dimension, values_from = value) %>%
  kbl(caption = "Solar Data Dimensions") %>%
  kable_material()
```


```{r inverter-missing, fig.cap = "Time Series of Power Inverter Failures"}
solar %>%
  anti_join(generation, by = c("plant_id", "date_time", "generation_source" = "source_key")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(generation$date_time)) +
  labs(x = "Date and Time",
       y = "Number of Missing Observations",
       fill = "Plant ID",
       color = "Plant ID")
```


Figure \@ref(fig:inverter-missing) shows the number of missing values from power sensors over time.
Notably, missing values at plant 4135001 seem to go across all 22 sensors.
Additionally, For much of the last week of may, plant 4136001 had about 4
power generation sensors that were offline.

```{r weather-missing, fig.cap = "Time Series of Weather Sensor Failures"}
solar %>%
  select(date_time, plant_id) %>%
  unique() %>%
  anti_join(weather, by = c("plant_id", "date_time")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(weather$date_time)) +
  labs(x = "Date and Time",
       y = "Number of Missing Observations",
       fill = "Plant ID",
       color = "Plant ID")
```

Figure \@ref(fig:weather-missing) shows the number of missing values from power sensors over time.
Note that  many of the missing values of one or both weather sensors align with
missing values of the generation sensors as well.
This might suggest maintenance or a failure of a kind that affected the entire plant.

```{r sensor-anomalies, fig.cap = "Sensor Aanomalies Over Time"}
solar %>%
  na.omit() %>%
  filter((dc_power == 0 & irradiation > 0)) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  labs(x = "Date and Time", 
       y = "Anamoly Count",
       fill = "Plant ID",
       color = "Plant ID")
```

Figure \@ref(fig:sensor-anomalies) displays anomalies in the sensor data.
Here, an anomaly is defined as an observation in which the irradiation measured
by the weather sensor is greater than 0, but no DC power is generated.
This is incredibly unlikely to happen in a functioning solar cell.
Without more information, it is hard to tell exactly what is happening in these
cases.
For example, is it true that the panels are not actually producing DC power, 
or is it the case simply that the power sensor is not detecting the generated power.

```{r combined-missing-anomalies, fig.cap = "Combined Sensor Anamolies and Missing Observations by Source"}
solar %>%
  group_by(plant_id, generation_source) %>%  
  filter((dc_power == 0 & irradiation > 0) | is.na(dc_power)) %>%
  tally() %>%
  arrange(desc(n)) %>%
  ggplot(aes(x = reorder(generation_source, -n), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Generation Sensor Key",
       y = "Anamoly or Missing Observation Count",
       fill = "Plant ID")
```

It is time to get more granular.
Are there specific sensors that might be contributing disproportionately to missing and anomalous data?

Figure \@ref(fig:combined-missing-anomalies) shows the total number of combined anomalies and missing
observations broken down for each source.
It is clear that plant 4136001 experiences many more problems, with four sources
contributing many problems.
Even the best 4136001 sensor performs worse than the worst 4135001 sensor.

```{r anomaly-per-sensor, fig.cap = "Anomaly Count Per Sensor"}
solar %>%
  na.omit() %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum((dc_power == 0 & irradiation > 0))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Generation Source Key",
       y = "Anomaly Count",
       fill = "Plant ID")
```

Figure \@ref(fig:anomaly-per-sensor) clearly shows that plant 4136001 has many
more anomalies occurring. 
Most sensors are reporting 2 to 4 times as many anomalies.


```{r combined-missing, fig.cap = "Combined Missing Observations Per Sensor"}
solar %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum(is.na(dc_power) | is.na(irradiation))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Generation Source Key",
       y = "Missing Observation Count", 
       fill = "Plant ID")
```

Figure \@{fig:combined-missing} shows an interesting phenomena.
Plant 4136001 has the worst offending sensors by a large margin.
Nearly 4 times as many observations were missed by 4 outstanding sensors.
The rest of the sensors at plant 4136001 have missed relatively few observations,
nearly none in many cases.
What could be causing this discrepancy?
Let us explore if there is a relationship between missing observations and anomalies.


```{r cluster-missing-anomaly, fig.cap = "Relationship Between Sensor NA and Anamoly"}
solar %>%
  group_by(plant_id, generation_source) %>%
  mutate(is_na = is.na(dc_power) | is.na(irradiation)) %>%
  mutate(likely_na = !is_na & dc_power == 0 & irradiation > 0) %>%
  summarize(na_rate = sum(is_na), likely_na_rate = sum(likely_na)) %>%
  ggplot(aes(x = na_rate, y = likely_na_rate, color = plant_id)) +
  geom_point() +
  labs(x = "Missing Observation Count",
       y = "Anamoly County",
       color = "Plant ID")
```

Figure \@ref(fig:cluster-missing-anomaly) shows the sensor grouping as a result of relating missing counts
to anomaly counts.
The plant since 4136001 cluster shows a healthiest collection of data, while
plant 4135001 clusters suggest that less missing data from a set does not
necessarily mean that the data is more trustworthy.

That is, as the missing observation count decreases at plant 4136001, the number
of anomalies increases.
This relationship suggests that despite an observation being made, one or more
values were corrupted.
Only in the case of a very high number of missing values does the number of 
anomalies approach the numbers of plant 4135001.

To increase the understanding of the value of data collected at both plants,
let us now turn our attention to the total yield.

```{r total-yield-4135001, fig.cap = "Plant 4135001 Total Yield Over Time"}
solar %>%
  filter(plant_id == "4135001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "Total Yield", 
       color = "Power Generaton Source")
```

Figure \@ref(fig:total-yield-4135001) shows a slowly growing total yield from 
every source.
The total yield of each power generation source increases at about the same rate,
and missing values appear to propagate across the sensors of the plant.

```{r total-yield-4136001, fig.cap = "Plant 4136001 Total Yield Over Time"}
solar %>%
  filter(plant_id == "4136001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "Total Yield", 
       color = "Power Generation Source")
```

Figure \@ref(fig:total-yield-4136001) reveals a few things.
First, the different sensors have been running for very different amounts of time.
To have total yields that high, many of these sensors have likely been recording
data for years longer than at plant 4135001.
This may account for the numbers of failure.

While the evidence does not clearly indicate what might cause strange sensor data, 
the data suggest frequent problems with the sensors.
This evidence, combined with the evidence provided by analyzing the DC power output
of the panels, justifies removal of plant 4136001 from the data set for model
development.


## Separating Validation Data {#separating_validation_data}

To best determine the overall efficacy of predictive models, the data sets
were broken into a validation set and a training set.
There were 34 days in the entire data set. 
So, the last three days were partitioned to be a validation set, against
which predictions would only be made after the models were finalized.
Later, to build the models themselves, the training data was separated further 
into a train set and test set, using days 30 - 31 for comparison.

```{r}
date_time_cutoff = make_date(2020, 06, 14)

generation_validation <- generation %>%
  filter(plant_id == "4135001") %>%
  filter(date_time >= date_time_cutoff) %>%
  mutate(dc_power = dc_power / 10)

weather_validation <- weather %>%
  filter(date_time >= date_time_cutoff) %>%
  filter(plant_id == "4135001")

generation_train <- generation %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001") %>%
  mutate(dc_power = dc_power / 10) # Adjust for unit conversion error

weather_train <- weather %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001")

solar <- join_generation_weather(generation_train, weather_train)
```

## Data Exploration {#data_exploration}

The data has been cleaned.
A validation data set has been partitioned.
To get some rough ideas of how a model may be constructed, let us explore the 
data for patterns.

### Generation {#generation}

```{r power-generation-summary}
generation_train %>%
  select(dc_power, ac_power, daily_yield) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  kbl(caption = "Summary of Power Generation Data") %>%
  kable_material()
```

While table \@ref(tab:power-generation-summary) gives an understanding of what
the entirety of plant 4135001 power generation looks like, it is important
to look at each sensor individually.

```{r dc-power-box-plot, fig.cap = "DC Power Output by Source"}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = dc_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Source Key",
       y = "DC Power")
```

Figure \@ref(fig:dc-power-box-plot) shows consistent medians across many of the 
sensors. 
Sensors 1BY6WEcLGh8j5v7 and bvBOhCH3iADSZry trend towards slightly lower values,
but only slightly.

```{r ac-power-box-plot, fig.cap = "AC Power Output by Source"}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = ac_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Source Key",
       y = "AC Power")

```

Figure \@ref(fig:ac-power-box-plot) shows similar results to examining the DC
data, unsurprisingly. 
Again, sensors 1BY6WEcLGh8j5v7 and bvBOhCH3iADSZry show signs of lowered efficacy.

```{r daily-yield-by-source, fig.cap = "Daily Yield by Source"}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = daily_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Source Key",
       y = "Daily Yield")
```

\@ref(fig:daily-yield-by-source) shows an interesting reversal.
Sensors 1BY6WEcLGh8j5v7 and bvBOhCH3iADSZry, though showing a lower median DC
output, have a slightly higher median daily yield.

```{r total-yield-by-source, fig.cap = "Total Yield By Source"}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Source Key",
       y = "Total Yield")
```

Figure \@ref(fig:total-yield-by-source) appears to be showing values all over the place.
However, what figure \@ref(fig:total-yield-by-source) really reveals is which of
the power generation sensors have been running the longest, and as such have
generated a larger total yield.

```{r total-yield-by-source-normalized, fig.cap = "Difference over Month of Total Yield by Source"}
generation_train %>%
  group_by(source_key) %>%
  mutate(total_yield = total_yield - min(total_yield)) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "Source Key",
       y = "Difference in Total Yield")
```

Figure \@ref(fig:total-yield-by-source-normalized) takes into account the 
cumulative yield of the sensor at at the start of the observations.
This normalized view shows general consistency, again with general under
performance from 1BY6WEcLGh8j5v7 and bvBOhCH3iADSZry.

```{r dc-power-day-overlay, fig.cap = "DC Power Output Over One Day"}
generation_train %>%
  group_by(source_key) %>%
  filter(date_time < make_date(2020, 05, 16)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = source_key), alpha = 0.75) +
  labs(x = "Time",
       y = "DC Power") +
  theme(legend.position = "none")
```

Figure \@ref(fig:dc-power-day-overlay) overlays the DC power output of each generation source during
the first day.
Before sunrise and after sunset, about 5:30 AM and 6:30 PM, no DC power is
is generated.
This is to be expected.
The power output grows, peaks, and drops off.
This is to be expected, if the angle of the sun is expected to impact the solar
panel output.
However, the data is much noisier than to be simply described by the angle of the sun.

Most sources follow similar paths, suggesting a plant-wide variable, like 
irradiation, is a driving force.
However, we also see that one source drops to 0 output around 9:15 AM while the
others only experience a dip.
Sensor faults will have an impact on predictions.

```{r average-dc-power-month, fig.cap = "Average DC Power Output Over One Month"}
# view all average for all of month
generation_train %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power)) %>%
  ggplot(aes(x = date_time, y = avg_dc_power)) +
  geom_line() +
  labs(x = "Date and Time", 
       y = "Average DC Power") +
  theme(legend.position = "none")
```

Figure \@ref(fig:average-dc-power-month) shows the average DC power from each power
generation source for the entire month.
The result is predictably periodic, peaking at about 1:15 PM each day.
Any trends up or down are not evident upon visual examination.

```{r daily-yield-overlay, fig.cap = "Daily Yield Over One Month",}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = date_time, y = daily_yield, color = source_key)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "Daily Yield")
```

Figure \@ref(fig:daily-yield-overlay) shows the cumulative daily yield of each sensor over the month.
This graph more clearly demonstrates the difference in DC output from day to day,
and that each solar power source outputs roughly the same amount every day.
The smoothness of the peaks might suggest that changes in weather are also 
generally smooth, if not also periodic.


### Weather

```{r}
# Ambient Temperature
weather_train %>%
  select(irradiation, module_temperature, ambient_temperature) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  kbl(caption = "Summary of Weather Sensor Data") %>%
  kable_material()
```

It is not surprising that the module and ambient temperature have roughly the same
median temperature, 24.7 degrees Celsius. However, the module temperature shows
a much greater spread in temperature, especially in higher directions.
The module also gets colder.
This suggests that the module has some sort of cooling system in an attempt to 
mitigate the higher temperatures that it reaches.
The existence of a cooling system suggests that the module has an ideal operating
temperature at which it most efficiently generates power.
Figure \@ref(fig:temperature-box-plot) visualizes the greater spread.

```{r temperature-box-plot, fig.cap = "Temperature Readings"}
weather_train %>%
  pivot_longer(cols = c(module_temperature, ambient_temperature), 
               names_pattern = "(.*)_",
               names_to = "sensor",
               values_to = "temperature") %>%
  group_by(sensor) %>%
  ggplot(aes(sensor, temperature)) +
  geom_boxplot() +
  labs(x = "Sensor",
       y = "Temperature")
```


```{r irradiation-distribution, fig.cap = "Irradiation Distribution"}
weather_train %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(x = "Irradiation",
       y = "Count")
```

Figure \@ref(fig:irradiation-distribution), a graph visualizing the distribution 
of the observed irradiation, does not reveal much information.
It is not surprising that the most common observed irradiation is 0, as whenever
the sun is down, the measured irradiation ought to be 0.


```{r irradiation-distribution-daytime, fig.cap = "Irradiation Distribution (Day Time Only)"}
weather_train %>%
  filter(irradiation > 0) %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(x = "Irradiation",
       y = "Count")
```

Figure \@ref(fig:irradiation-distribution-daytime), in which nighttime
observations have been removed, reveals an interesting quirk.
There is a secondary mode for irradiation at about 0.5.
This may have to do with how sunlight passes through the atmosphere before reaching
the solar panels.
At certain angles, enough sunlight is scattered that the irradiation remains low.
Once the angle of reflection has been breached, irradiation increases as the angle
of the sunlight approaches normal, or 90 degrees.
Regardless, this graph reveals there is more to the irradiation reaching the solar
panels than simple geometry.

```{r irradiation-time-series, fig.cap = "Irradiation Over Time",}
weather_train %>%
  ggplot(aes(x = date_time, y = irradiation, fill = plant_id)) +
  geom_line() +
  labs(x = "Date and Time",
       y = "Irradiation")
```

Figure \@ref(fig:irradiation-time-series) displays that irradiation over time
follows a pattern that looks very similar to the 
graph generated of DC power output over time.
It is periodic, with a frequency of 1 day, peaking at approximately 1 PM.

```{r temp-time-series, fig.cap = "Temperature Over Time"}
weather_train %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = module_temperature, color = "Module")) +
  geom_line(aes(y = ambient_temperature, color = "Ambient")) +
  labs(x = "Date and Time",
       y = "Temperature (Celsius)") +
  guides(color = guide_legend(title = "Sensor"))
```

Figure \@ref(fig:temp-time-series) shows that the temperature data also 
follows what might be expected after seeing the summary table.
The module temperature varies much more than the ambient temperature.
However, note that the ambient temperature actually lags behind the module
temperature.
The relationship between irradiation and temperatures will be further examined below.

```{r, eval = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = irradiation, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Irradiation Over a Day",
       x = "Time",
       y = "Irradiation")
```


```{r, eval = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = module_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Module Temperature Over the Day",
       x = "Time",
       y = "Module Temperature (Celsius)")
```


```{r, eval = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = ambient_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Ambient Temperature Over the Day",
       x = "Time",
       y = "Ambient Temperature (Celsius)")
```

```{r, eval = FALSE}
#Irradiation appears to be very noisy.
#Yet it is enveloped by a parabola that represents the maximum light from
#the sun reaching the solar panel.
#The module temperature 
#Ambient: Trends DOWN from may to june
```

```{r averaged-weather-data, fig.cap = "Averaged Weather Data"}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  summarize(avg_irradiation = mean(irradiation) * 40 + 20,
            avg_module_temperature = mean(module_temperature),
            avg_ambient_temperature = mean(ambient_temperature)) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = avg_irradiation, color = "Irradiation X 40 + 20")) +
  geom_line(aes(y = avg_module_temperature, color = "Module Temperature")) +
  geom_line(aes(y = avg_ambient_temperature, color = "Ambient Temperature")) +
  labs(x = "Time of Day",
       y = "Temperature") +
  guides(color = guide_legend(title = "Average"))
```

Note that in figure \@ref(fig:averaged-weather-data), the scale of the irradiation has been multiplied 
by 40 and shifted up 20 degrees to better visualize the relationship with
module temperature and its lag.
Irradiation leads module temperature by about 15 minutes and ambient temperature
by a number of hours.
However, the module temperature appears to be some composition of the ambient
temperature and irradiation.
This might suggest that the weather data can largely be described by the 
irradiation, or by the irradiation and the ambient temperature.


## Correlation


```{r ac-dc-tab, eval=FALSE}
solar %>%
  na.omit() %>%
  select(dc_power, ac_power) %>%
  cor() %>%
  .[1, 2] %>%
  tibble("AC/DC Correlation" = .) %>%
  kbl() %>%
  kable_material()
```

The correlation between the DC Power and AC Power was found to be 1. 
They are highly correlated.
This aligns with expectations, that a certain percent of power is lost in
during conversion.
The loss can be determined by fitting the data to a line.

```{r ac-dc-line-fit}
fit <- solar %>%
  lm(ac_power ~ dc_power, data = .)

fit %>%
  tidy() %>%
  kbl(caption="AC Power per DC Power Line Fit") %>%
  kable_material()
```


```{r ac-dc-fit-graph, fig.cap = "AC Power Produced per DC Power In"}
solar %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point(alpha = 0.25) +
  geom_abline(slope = fit$coefficients[2], intercept = fit$coefficients[1], size = 1) +
  labs(x = "DC Power",
       y = "AC Power")
```

The fit shown in table \@rec(tab:ac-dc-line-fit) suggests a 97.7% conversion rate 
from DC to AC power, only 2.3% is lost. 
Such a small loss suggests that the plants are using high quality transformers.
We can see in figure  \@ref(fig:ac-dc-fit-graph) that the fit is good. 

### Lag

While exploring the weather data, a lag was noted between irradiation, module
temperature, and ambient temperature.
This could represent some relationship between the three.
Because of the physical properties of temperature and heat flow, it is likely
that irradiation drives both the module temperature and the ambient temperature.
It is unlikely that the module temperature has an effect on the ambient
temperature.
It is possible that the ambient temperature acts as a heat or cold sink for the
module.

For a better understanding of what may be going on with weather at the power
plant, the values of the weather sensors are treated as time series.

```{r cc-irr-mod, fig.cap = "Cross Correlation Between Irradiation and Module Temperature"}
weather_tsbl <- weather_train %>%
  as_tsibble(index = date_time) %>%
  fill_gaps()

weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(x = "Lag",
       y = "Correlation")
```


```{r cc-irr-mod-max}
weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption="Lag of Maximum Cross Correlation Between Irradiation and Module Temperature") %>%
  kable_material()
```

A strong correlation is found between the irradiation and the module temperature
after a 15 minute lag, as shown in figure \@ref(fig:cc-irr-mod) and table 
\@ref(tab:cc-irr-mod-max).
This can be explained by the radiation heat transfer as a result of the 
electromagnetic radiation of the sun.
It does not take long for higher irradiation to increase the temperature of the module.
However, referring back to the average day temperatures graph, it appears that
as the radiation increases, temperature increases without lag
As the radiation decreases, the temperature decreases after about 30 minutes.

```{r cc-irr-amb, fig.cap = "Cross Correlation Between Irradiation and Ambient Temperature"}
weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(title = ,
       x = "Lag",
       y = "Correlation")
```


```{r cc-irr-amb-max}
weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 48) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption="Lag of Maximum Cross Correlation Between Irradiation and Ambient Temperature") %>%
  kable_material()
```

The connection between irradiation and ambient temperature is less clear. 
The correlation of 0.877 after an hour and fifteen minutes suggested that
irradiation has some effect on the ambient temperature.
The increased lag time has to do with how much less interaction there is between
rays from the sun and air molecules vs a stationary module.
However, there are sufficient confounding and unobserved variables related to 
weather and weather prediction that it is beyond the scope of this analysis to dig
deeper.

```{r cc-amb-mod, fig.cap = "Cross Correlation Between Module Temperature and Ambient Temperature"} 
weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(x = "Lag",
       y = "Correlation")
```


```{r cc-amb-mod-max}
weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 48) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption="Lag of Maximum Cross Correlation Between Module Temperature and Ambient Temperature") %>%
  kable_material()
```

Interestingly, the ambient temperature lags the module temperature, and by 45
minutes, as shown in table \@ref(tab:cc-amb-mod-max).
At first glance, this does not make much sense.
It is unlikely that a module could be driving the ambient temperature.

However, if one keeps in mind the confounding variable of weather, the relationship 
between irradiation and module temperature explains this.
It is far more likely that the ambient environment acts as a heat sink when the
module becomes very hot.
Though the physical interactions of heat transfer might be modeled, they are
outside the scope of this analysis.


## Building The Linear Regression Model

### Splitting the Train and Test Sets

A validation data set has already been separated from the data.
However, to evaluate the efficacy of the model as it is constructed, it becomes
necessary to further partition the data to avoid over training.
The final two days of the solar data are put into a test set, all other data
remain in a train set.

```{r}
test_set <- solar %>%
  filter(date_time > make_date(2020, 06, 12))

train_set <- solar %>%
  anti_join(test_set)
```


### Baseline (Naive RMSE) {#naive_rmse}

The RMSE is the metric by which success is measured.
To get an understanding of how much the model is improving, the naive RMSE will
be calculated as a baseline.
That is, the predicted dc_power will simply be the mean of all dc_power observed.

```{r}
RMSE <- function(predicted_power, test_power){
  sqrt(mean((test_power - predicted_power) ^ 2, na.rm = TRUE))
}

mu_hat <- mean(train_set$dc_power, na.rm = TRUE) # 321.0874

naive_rmse <- RMSE(mu_hat, test_set$dc_power) # 401.8058

results <- tibble(method = "Average", RMSE = naive_rmse)

tibble(mu_hat = mu_hat, naive_rmse = naive_rmse) %>%
  kbl() %>%
  kable_material()
```

The average of the dc_power over the entire data set is 321.
Predicting the average dc_power results in an RMSE of 402.
That is substantial error.
Time to explore ways to reducing reduce it.


### Generation Source Effect {#generation_source_effect}

To start, the effect of stratifying by generation source is examined. The results
are shown in table \@ref(tab:average-by-source-model).

```{r}
average_source <- train_set %>%
  group_by(generation_source) %>%
  summarize(avg_dc_power = mu_hat - mean(dc_power, na.rm = TRUE))

predicted_power <- average_source %>%
  right_join(test_set) %>%
  pull(avg_dc_power) %>%
  + mu_hat

average_by_source_RMSE <- RMSE(predicted_power, test_set$dc_power)
result <- tibble(method = "Average by Source", 
                 RMSE = average_by_source_RMSE)
results <- results %>%
  add_row(result)
```


```{r average-by-source-model}
result %>%
  kbl(caption = "Model Results") %>%
  kable_material()
```

A slight improvement, but only slight. About a quarter of a percent.

### Irradiation Effect {#irradiation_effect}

In exploration, it was observed that irradiation and DC power output were highly
correlated. 
A linear regression method was used to predict DC power output based purely on 
irradiation, using the train set to predict against the test set.
The result is shown in table \@ref(tab:irradiation-effect).

```{r}
fit <- lm(dc_power ~ irradiation, data = train_set)
predicted_power <- predict(fit, newdata = test_set)

irradiation_rmse <- RMSE(predicted_power, test_set$dc_power) # 583.1007

result <- tibble(method = "Irradiation Effect", 
                 RMSE = irradiation_rmse)

results <- results %>%
  add_row(result)
```

```{r irradiation-effect}
result %>%
  kbl(caption = "Irradiation Effect") %>%
  kable_material()
```

An RMSE of 44.4 is, unsurprisingly, a substantial improvement over the naive RMSE.

```{r irr-fit, fig.cap = "Irradiation Fit"}
train_set %>%
  ggplot(aes(irradiation, dc_power, color = plant_id)) +
  geom_point(alpha = 0.1) +
  geom_abline(slope = fit$coefficients[2],
              intercept = fit$coefficients[1],
              size = 1) +
  labs(x = "Irradiation",
       y = "DC Power",
       color = "Plant ID")
```

Figure \@ref(fig:irr-fit) shows the line that resulted from linear regression,
and suggests that a linear relationship fits rather well.
How much can the RMSE be improved upon using a linear model, beyond using solely irradiation
as a predictor?


### Module Temperature Effect {#module_temperature_effect}

It is not unreasonable to consider other weather effects to construct the model.
We can get a better understanding of how temperature effects the DC power output by
sweeping away the irradiation effect and plotting the resulting residual against
the module temperature. The results are shown in figure \@ref(fig:mod-temp-eff).

```{r mod-temp-eff, fig.cap = "Module Temperature Effect"}
train_set %>%
  mutate(dc_power_resid = dc_power - irradiation * fit$coefficients[2] - fit$coefficients[1]) %>%
  ggplot(aes(module_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "black") +
  labs(x = "Module Temperature",
       y = "DC Power Residual")
```

Figure \@ref(fig:mod-temp-eff), relating module temperature and the DC power output, suggests 
that the module has an optimal operating temperature between 20 and 54 degrees.
The relationship does not appear to be a straight line, however.
Perhaps the module temperature effect is best represented by parabola.

To account for the parabolic shape of the data, a placeholder variable was added to the train
and test sets that was simply the squared module temperature.
Then, a fit was made based on irradiation, module temperature, and the module
temperature squared. The results may be seen in table \@ref(tab:irr-mod-temp-tab).

```{r}
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)

irradiation_module_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 40.03656

result <- tibble(method = "Irradiation + Module Temperature Effect",
                 RMSE = irradiation_module_temperature_rmse)

results <- results %>%
  add_row(result)

```

```{r irr-mod-temp-tab}
result %>%
  kbl(caption = "Module Temperature Effect") %>%
  kable_material()
```

40.0, a %9.9 improvement over the prediction made purely on the irradiation effect.

Earlier, it was discovered that module temperature lagged irradiation by 15 minutes
and was highly correlated.
Can a similar RMSE be achieved by simply lagging the irradiation by 15 minutes?

The `lag` function from dplyr allows the creation of a placeholder variable that
hold the irradiation value from 15 minutes prior (the previous data entry).
A second placeholder variable contains the squared lag value.
Note, the lagged time series results in an NA.
Since this is at night, the NA is be replaced with the lowest predicted dc_power.

```{r}
fit_irr <- train_set %>% 
  mutate(lag_irradiation = lag(irradiation, 1),
         lag_irradiation_sq = lag_irradiation ^2) %>%
  lm(dc_power ~ irradiation + lag_irradiation + lag_irradiation_sq, data = .)

predicted_power <- test_set %>%
  mutate(lag_irradiation = lag(irradiation, 1),
         lag_irradiation_sq = lag_irradiation ^2) %>%
  predict(fit_irr, newdata = .) %>%
  replace_na(min(., na.rm = TRUE))

irradiation_lag_rmse <- RMSE(predicted_power, test_set$dc_power)

result <- tibble(method = "Irradiation + Irradiation Lag Effect",
                 RMSE = irradiation_lag_rmse)

results <- results %>%
  add_row(result)
```

```{r}
result %>%
  kbl() %>%
  kable_material()
```

40.61, about %1 worse than if module temperature was incorporated instead.

### Ambient Temperature Effect {#ambient_temperature_effect}

Now, the residual DC power is compared to the ambient temperature, similar to how
module temperature was examined.
The result of sweeping out the irradiation and module temperature squared effect
are shown in figure \@ref(fig:amb-temp-eff).

```{r amb-temp-eff, fig.cap = "Ambient Temperature Effect"}
train_set %>%
  mutate(dc_power_resid = dc_power 
         - fit$coefficients[1] 
         - irradiation * fit$coefficients[2] 
         - module_temperature * fit$coefficients[3]
         - module_temperature ^ 2 * fit$coefficients[4]) %>%
  ggplot(aes(ambient_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.01) +
  geom_smooth(color = "black") +
  labs(x = "Ambient Temperature",
       y = "DC Power Residual")
```

Figure \@ref(fig:amb-temp-eff) suggests there is a negligible effect.

```{r}
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + 
                 module_temperature + 
                 module_temperature_sq +
                 ambient_temperature, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)

irradiation_module_ambient_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 39.86

result <- tibble(method = "Irradiation + Module + Ambient Temperature Effect",
                 RMSE = irradiation_module_ambient_temperature_rmse)

results <- results %>%
  add_row(result)
```


```{r amb-temp-eff-tab}
result %>%
  kbl(caption = "Ambient Temperature Effect") %>%
  kable_material()
```

Table \@ref(tab:amb-temp-eff-tab) reinforces what was assumed from 
figure \@ref(fig:amb-temp-eff).
Adding ambient temperature to the models results in an improvement of less than half of a percent.

### Clamping and Sensor Faults {#clamping_and_sensor_faults}

Let's take a glance look at how our predictions compare to the test data.
A summary is shown in \@ref(tab:predict-summary).

```{r predict-summary}
summary(predicted_power) %>%
  bind_rows(summary(test_set$dc_power)) %>%
  as_tibble() %>%
  add_column(.before = "Min.", DC_Power = c("Predicted", "Test Set")) %>%
  kbl(caption="Summary of Linear Fit Predictions") %>%
  kable_material()
```

Immediately, a source of improvement presents itself.
It is not physically possible for negative DC power to be produced.
Negative DC Power would suggest that the solar panels are drawing energy in.
To account for this impossibility, a clamped prediction increases any results DC Power that is
less than 0 to 0.
The results of clamping may be seen in table \@ref(tab:clamp)

```{r}
predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(pred < 0, 0, pred))
  

clamped_rmse <- 
  RMSE(predicted_power$pred, test_set$dc_power)

result <- tibble(method = "Clamped",
           RMSE = clamped_rmse)

results <- results %>%
  add_row(result)
```

```{r clamp}
result %>%
  kbl(caption = "Clamping Effect") %>%
  kable_material()
```

Other intuitive improvements may be made.
For example, consider the anomalous data found during exploratory analysis.
Do we improve the predictive model if we do not train anomalous data?

```{r}
fit <- train_set %>%
  filter(irradiation > 0 & dc_power > 0) %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + 
                 module_temperature + 
                 module_temperature_sq +
                 ambient_temperature, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(pred < 0 | irradiation == 0, 0, pred))
  

clamped_fixed_rmse <- 
  RMSE(predicted_power$pred, test_set$dc_power)

result <- tibble(method = "Clamped + Anomolies Removed", 
          RMSE = clamped_fixed_rmse)

results <- results %>%
  add_row(result)
```

```{r clamped-no-anomaly}
result %>%
  kbl() %>%
  kable_material()
```

Table \@ref(tab: clamped-no-anomaly) shows the result of removing anomalies from
the training data and clamping the prediction.

39.15 is a considerable improvement of 90.3% over the naive RMSE.
The final clamped RMSE of 39.15 is an 11.8 % improvement on the uni-variate
linear regression prediction based on irradiation. Figure \@ref(fig:lm-prediction)
shows the final fit.
The colored lines represent the observed DC output at teach plant.
The black line represents the final linear fit.

```{r lm-prediction, fig.cap = "Final Linear Prediction on Test Set"}
predicted_power %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = generation_source), alpha = 0.25) +
  geom_line(aes(y = pred), size = 1) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```


## Building the ARIMA Model {#arima}

ARIMA stands for **A**uto-**R**egressive **I**ntegrated **M**oving **A**verage.
It is a statistical analysis model that uses time series data to predict trends.
Auto-Regressive: Predicts future values based on past values, regresses on its own lagged values
Integrated: Differences raw observations to make the time series stationary
Moving Average: Smooths out time series data by creating a subset of recent data to use as an average
auto.arima (from forecast) and ARIMA (from fable) automatically determine the p, q, and d parameters,
that is, the parameters used in the auto-regression, integration, and the moving average.


### Averaged ARIMA

Below is the result of running an auro.arima on the train set, after averaging
the observed DC power from each power generation source.
Figure \@ref(fig:arima-forecast) shows the predicted result for the test set days.


```{r}
test_date_times <- test_set %>%
  pull(date_time) %>%
  unique()

generation_sources <- test_set %>%
  pull(generation_source) %>%
  unique()

arima_result <- train_set %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power, na.rm = TRUE)) %>%
  pull(avg_dc_power) %>%
  ts(frequency = 96)  %>% # 4 * 24 for every 15 minutes over 24 hours
  auto.arima(seasonal = TRUE)

arima_result
```


```{r arima-forecast, fig.cap = "ARIMA Forcecast on Test Set"}
forecast_result <- arima_result %>%
  forecast(h = length(test_date_times)) %>%
  plot()
```


```{r}
predicted_power <- tibble(date_time = test_date_times, pred = forecast_result$mean)
predicted_power <- expand_grid(date_time = test_date_times,
                               generation_source = generation_sources) %>%
  left_join(predicted_power, by = "date_time")

arima_rmse <- RMSE(predicted_power$pred, test_set$dc_power) 

result <- tibble(method = "ARIMA",
                 RMSE = arima_rmse)

results <- results %>%
  add_row(result)
```

```{r arima-tab}
result %>%
  kbl(caption = "ARIMA RMSE") %>%
  kable_material() # 179.0664
```
Table \@ref(tab:arima-tab) shows the RMSE of the ARIMA model.
An RMSE of 179 is much worse than the irradiation prediction, but it is important
to keep in mind that this prediction was made using *only* DC power as a predictor.
The fact that it improves so much over the average is impressive.

### ARIMA By Generation Source {#arima_by_generation_source}

It is possible through the use of tsibbles and the fable package to be more 
granular with ARIMA.
In particular, it may be separated to apply only to each group.
The previous ARIMA model used only the average dc.
Table \@ref(tab:arima-by-source) shows the result of applying an ARIMA fit to each
group.

```{r}
ts_train_set <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)
  
arima_models <- ts_train_set %>%
  group_by(generation_source) %>%
  model(arima = ARIMA(dc_power ~ irradiation + module_temperature + module_temperature_sq))

ts_test_set <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time) %>%
  group_by(generation_source)

predicted_power <- forecast(arima_models, new_data = ts_test_set) %>%
  as_tibble() %>%
  select(generation_source, date_time, pred = .mean) %>%
  mutate(pred = ifelse(pred < 0, 0, pred)) %>%
  left_join(ts_test_set, by = c("date_time", "generation_source"))

arima_source_rmse <- RMSE(predicted_power$pred, 
                          predicted_power$dc_power)

result <- tibble(method = "ARIMA by Source",
                 RMSE = arima_source_rmse)

results <- results %>%
  add_row(result)
```

```{r arima-by-source}
result %>%
  kbl(caption = "Result of Applying ARIMA to Each Generation Source") %>%
  kable_material()
```
Stratifying by generation source significantly reduced the RMSE of applying
the ARIMA.
This is an improvement on the uni-variate linear regression, but does not hold
up to the multivariate models.
Note that for this result, clamping predictions to be greater than 0 was applied.
Clamping only reduced the RMSE by 0.3.
The individualized-by-source fits are shown in figure \@ref(fig:arima-pred).

While there exist methods to include external regressors to an ARIMA fit, those
models will be left for future work.


```{r arima-pred, fig.cap = "Arima Prediction for Test Days", fig.height = 28, fig.width = 20}
predicted_power %>%
  group_by(date_time) %>%
  mutate(pred = mean(pred)) %>%
  ggplot(aes(x = date_time)) +
  geom_point(aes(y = dc_power, color = generation_source), alpha = 0.75) +
  geom_line(aes(y = pred)) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```


## Building the Random Forest Model {#random_forest}

First, a linear model was constructed out of the variables that the author
could think to reasonably include.
Then, an ARIMA model was applied to the DC power to get single dimensional results.
Now, the floor will be opened to all observed variables by using random forest
to make predictions.

Random forest will require the data to be presented in a slightly different format.
For example, the date_time is split into the days since the first observations,
the hour of the day the observation, and the minute of the hour the observation.
Generation sources are treated as factors, rather than groups.
Additional variables are created out of squaring the irradiation, module
temperature, and ambient temperature.

AC power, daily yield, and total yield are all removed from prediction.
Though their previously recorded values could be incorporated with lag, AC power,
daily yield, and total yield are all direct results of DC power, and do not make
realistic predictors if this model were ever applied to future days.

Additionally, date time, plant id, and weather source are all removed due to redundancy.
The fit is shown below.

```{r, fig.height=28, fig.width=20}
set.seed(1)
train_set_wide <- train_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = as.factor(generation_source),
         irradiation_sq = irradiation ^ 2,
         module_temperature_sq = module_temperature ^2,
         ambient_temperature_sq = ambient_temperature ^ 2) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power)

test_set_wide <- test_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = factor(generation_source),
         irradiation_sq = irradiation ^ 2,
         module_temperature_sq = module_temperature ^2,
         ambient_temperature_sq = ambient_temperature ^ 2) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power)

fit_rf <- train(dc_power ~ .,
                data = train_set_wide,
                method = "ranger",
                trControl = trainControl(method = "cv", number = 5, repeats = 8, allowParallel = TRUE), #Add verbose = TRUE to se it as it goes
                importance = 'impurity',
                na.action = na.omit)
```

Now, let us take a look at what the importance of various variables in building
the model.
The importance of each model, extracted with varImp, is shown in figure
\@ref(fig:var-imp).
Figure \@ref(fig:var-imp) clearly shows that irradiation, irradiation squared,
module temperature, and module temperature squared dominate the predictions.
This is in line with the previously constructed linear model.

Interestingly, ambient temperature remains a relevant predictor.
And despite the early assumption that the time of day help little importance,
it still makes an appearance on.

Day, minute, and generation source are all of negligible effect.


```{r var-imp, fig.cap = "Importance of Features in Random Forest"}
ggplot(varImp(fit_rf))
```

Figure \@ref(fig:rf-plot) displays the predicted DC power for each generation 
source on the test set.
Other collections of variables applied did not improve the result.
For example, despite the generation sources showing little importance, removing them
from the random forest training data was detrimental to predictions on the test set.
The result of the random forest fit to the test set is shown in table \@ref(tab:rf-tab)

```{r rf-plot, fig.cap = "Random Forest Prediction on Test Set"}
pred_rf <- predict(fit_rf, test_set_wide)

result <- tibble(method = "Random Forest",
                 RMSE = RMSE(pred_rf, test_set$dc_power))
results <- results %>%
  add_row(result)

prediction <- test_set %>%
  add_column(pred = pred_rf)

prediction %>%
  group_by(date_time) %>%
  mutate(pred = mean(pred)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = generation_source), alpha = 0.75) +
  geom_line(aes(y = pred)) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```

```{r rf-tab}
result %>%
  kbl(caption = "Random Forest RMSE") %>%
  kable_material()
```

# Results {#results}

## Model Root Mean Squared Errors {#RMSES}

The RMSEs of the prediction from each model are shown in table \@ref(tab:results-tab).

```{r results-tab}
results %>%
  kbl(caption = "RMSE of Each Model on the Test Set") %>%
  kable_material()
```


## Final Validation {#final_validation}

Finally, the training data and test data were recombined into the solar data.
The solar data was used to train a prediction to be applied to the 
validation data set, separated at the beginning of model development.
The three models were the best fitting linear regression model, shown in figure
\@ref(fig:validation-linear-graph), the ARIMA model based on the average DC 
power generated by the various sources, shown in figure 
\@ref(fig:arima-validation-graph), and the random forest model, shown in figure 
\@ref(fig:rf-validation-graph).


```{r validation-linear}
validation <- join_generation_weather(generation_validation, weather_validation)

fit <- solar %>%
  filter(irradiation > 0 & dc_power > 0) %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + 
                 module_temperature + 
                 module_temperature_sq +
                 ambient_temperature, data = .)

predicted_power <- validation %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(pred < 0 | irradiation == 0, 0, pred))
  

validation_results <- tibble(method = "Linear Regression", 
         RMSE = RMSE(predicted_power$pred, validation$dc_power))

```

```{r validation-linear-graph, fig.cap = "Linear Regression Predictions on Validation Set"}
predicted_power %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = generation_source), alpha = 0.75) +
  geom_line(aes(y = pred)) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```


```{r validation-arima}
ts_train_set <- solar %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)
  
arima_models <- ts_train_set %>%
  group_by(generation_source) %>%
  model(arima = ARIMA(dc_power ~ irradiation + module_temperature + module_temperature_sq))

ts_test_set <- validation %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time) %>%
  group_by(generation_source)

predicted_power <- forecast(arima_models, new_data = ts_test_set) %>%
  as_tibble() %>%
  select(generation_source, date_time, pred = .mean) %>%
  mutate(pred = ifelse(pred < 0, 0, pred)) %>%
  left_join(ts_test_set, by = c("date_time", "generation_source"))

validation_results <- validation_results %>%
  add_row(method = "ARIMA Forecast", 
         RMSE = RMSE(predicted_power$pred, predicted_power$dc_power))

###############################
#
#test_date_times <- validation %>%
#   pull(date_time) %>%
#   unique()
# 
# generation_sources <- validation %>%
#   pull(generation_source) %>%
#   unique()
# 
# arima_result <- solar %>%
#   group_by(date_time) %>%
#   summarize(avg_dc_power = mean(dc_power, na.rm = TRUE)) %>%
#   pull(avg_dc_power) %>%
#   ts(frequency = 96)  %>% # 4 * 24 for every 15 minutes over 24 hours
#   auto.arima(seasonal = TRUE)
# 
# forecast_result <- arima_result %>%
#   forecast(h = length(test_date_times)) %>%
#   plot()
# 
# predicted_power <- tibble(date_time = test_date_times, pred = forecast_result$mean)
# predicted_power <- expand_grid(date_time = test_date_times,
#                                generation_source = generation_sources) %>%
#   left_join(predicted_power, by = "date_time")
# 
# validation_results <- validation_results %>%
#   add_row(method = "ARIMA",
#           RMSE = RMSE(predicted_power$pred, validation$dc_power))
```
```{r arima-validation-graph, fig.cap = "ARIMA Forecast on Validation Days"}
predicted_power %>%
  group_by(date_time) %>%
  mutate(pred = mean(pred)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = generation_source), alpha = 0.75) +
  geom_line(aes(y = pred)) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```



```{r validation-rf}
set.seed(1)
train_set_wide <- solar %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = as.factor(generation_source),
         irradiation_sq = irradiation ^ 2,
         module_temperature_sq = module_temperature ^2,
         ambient_temperature_sq = ambient_temperature ^ 2) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power)

test_set_wide <- validation %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = factor(generation_source),
         irradiation_sq = irradiation ^ 2,
         module_temperature_sq = module_temperature ^2,
         ambient_temperature_sq = ambient_temperature ^ 2) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power)

fit_rf <- train(dc_power ~ .,
                data = train_set_wide,
                method = "ranger",
                trControl = trainControl(method = "cv", number = 5, repeats = 8, allowParallel = TRUE), #Add verbose = TRUE to se it as it goes
                importance = 'impurity',
                na.action = na.omit)

pred_rf <- predict(fit_rf, test_set_wide)

validation_results <- validation_results %>%
  add_row(method = "Random Forest",
          RMSE = RMSE(pred_rf, validation$dc_power))
```

```{r rf-validation-graph, fig.cap = "Random Forest Predictions on Validation Set"}
validation %>%
  add_column(pred_rf = pred_rf) %>%
  group_by(date_time) %>%
  mutate(pred_rf = mean(pred_rf)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = generation_source)) +
  geom_line(aes(y = pred_rf)) +
  theme(legend.position = "none") +
  labs(x = "Date and Time",
       y = "DC Power")
```

The RMSEs of the various predictions are shown in table \@ref(tab:validation-results).

```{r validation-results}
validation_results %>%
  kbl(caption = "Validation RMSEs") %>%
  kable_material()
```

# Conclusion {#conclusion}

## Summary

Exploratory analysis was conducted to see the patterns of the power generation 
data and the weather data.
Sanity checks on the data revealed that the data produced by one of the plants
would be very difficult to conduct analysis on.
The problematic plant was removed from further explorations.

Correlations between different variables were explored.
It was confirmed that AC power and DC power were highly correlated.
The inverters at the plant displayed a 97.7% conversion rate from DC power to AC
power.
Module temperature was highly correlated to irradiation, especially after a 15
minute lag.

A validation set was separated containing the last 4 days of the data set.
A linear regression model was tested and refined. 
An ARIMA model was applied to the data set.
Finally, random forest was employed to achieve the best prediction.
The random forest variable importance results reinforced the findings of the
refined linear regression model.

Finally, the predictions were trained on all of the non-validation data and used
to predict the validation data.
The resulting RMSEs were higher for the validation set.
The higher RMSEs suggest some amount of over training.
However, it may be observed in the graphs of the fit that the validation data
had missing values and sharp drops in DC power.
Sudden plunges to 0 DC power suggest a sensor fault of some kind, which would
negatively impact RMSE as they were not accounted for in the model.

## Potential Impact

The refined linear regression model and the random forest predictions both
produced reasonable improvements over the most basic linear regression model
built solely on irradiation.
A plant seeking to improve their predictive abilities on DC Power, and thus
the AC power that the plant contributed towards an electric grid, could use either
model to great effect.

## Limitations

Unfortunately, the noisiness of missing or anomalous observations at plant 
4136001 made predictions very difficult.
Without cleaner data with which to work, making accurate predictions for the 
DC power output of plant 4136001 was outside the scope of this analysis.

The weather sensor data was fairly limited.
As was noted in the importance of variables determined by the random forest,
the hour of an observation has some observable impact on the DC power.
Time is expected to be a confounding variable of weather, not a driving 
variable in itself.
Thus, the hour being a non-negligible variable suggests that there were aspects
of the weather or surrounding environment that were both influenced by the time
of day and also impacted DC power.

The data included in this data set covered only 34 days.
Multiple months or even many years of data could possibly reveal greater
periodicity in the data.
Additionally, since plant 4136001 appears to have been in operation longer,
it may reveal when plant-wide outages appear.

## Future Work

While data collected at plant 4136001 did not serve well to make predictions on 
the DC power, the data could serve well to develop a system to predict sensor 
faults before they occur.
It could be possible that irradiation levels, temperature, or a host of other 
observable variables correlate to a missing observation or anomalous data.

Treating the data as a time series and accounting for lag revealed lagged 
correlation between irradiation, module temperature, and ambient temperature.
Irradiation and ambient temperature may be predicted in advance, to some extent,
from a meteorological organization.
Module temperature, however, is specific to the plant.
Thus, developing a model to predict module temperature from other future-predictable
variables allow more actionable results.

More work could be done to incorporate predictable weather data.
That is, data could be queried from other data bases to find information about
wind speed, cloud cover, precipitation, etc.
A more sophisticated model could then be constructed that requires only the 
predicted weather that day to make a reasonable estimation of the DC power the
plant would produce.
This is the best case scenario for the plant, as they could use publicly
available weather data to predict the impact on the electrical grid each day.

In this analysis, three models were built: Linear Regression, ARIMA, and Random
Forest. 
Other methods were explored, for example Principle Component Analysis,
but were found to be less effective than even predicting the average.
A powerful approach for future work would be to assemble an ensemble 
model combining models that consider a-temporal variables, like the Random Forest,
and a model that acknowledges the time series qualities of the data, like ARIMA.