---
title: "solar-plant-power-generation"
author: "Alexander McIntosh"
date: "7/15/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, # Default to false considering I hope to use mostly graphs
  message = FALSE,
  warning = FALSE,
  tidy = TRUE,
  cahe = TRUE, # Set to FALSE to conserve memory
  eval = FALSE # Set to TRUE for code to actually rune
)
```

# Introduction

As the unintended consequences of traditional energy collection become untenable,
the world is turning to alternative, renewable energy sources.
Solar power has become particularly popular for a host of reasons.
However, a notable drawback of solar power is its lack of consistency.
Inconsistency is a significant challenge for interacting with an external power grid.

In the analysis to follow, using only the data collected at the solar power plant,
the power output of the plant will be predicted based only on data the plant
has available.
First, suspicious data are examined for usability.
Then, the clean data are explored for patterns, correlation, and causality. 
Finally, four models are engineered using linear regression, ARIMA, random forest
machine learning, and dimension reduction through principle component analysis.
The success of each model is measured by the model's ability to predict three
days worth of data, separated before the models' construction.

For brevity and readability, many of the transformations used on the data to 
produce graphs are not included in this report.
For more information about how the graphs and results were generated for this
report, see <http://www.github.com/mcintalmo/solar-plant-power-generation> . 
The link includes the R Markdown that generated this report and the 
notebook used for exploration.

To explore the raw data, see
*Solar Power Generation Data* from user Ani Kanal on Kaggle. 
<https://www.kaggle.com/datasets/ef9660b4985471a8797501c8970009f36c5b3515213e2676cf40f540f0100e54> 
Or use command 
```
kaggle datasets download -d anikannal/solar-power-generation-data
```

# Methods and Analysis

This analysis was conducted entirely within R. 
Packages included tidyverse and broom for data organization and transformation.
Lubridate and hms allowed for time stamp transformation.
Forecast, fable, and feasts provided the backbone of analysis of the data as a 
time series and use of the ARIMA model.
Ranger, randomForest, pls, and caret all contributed functions for developing
a machine learning model.

```{r packages, echo = FALSE}
library(tidyverse)
library(broom)
library(lubridate)
library(hms)
library(forecast)
library(tsibble)
library(feasts)
library(fable) # Requires installing "feasts" package
library(ranger)
library(randomForest)
library(pls)
library(caret)
```
## Data Collection
The data for this analysis was collected by two solar plants in India.

The first plant, id: 4135001, is near Gandikotta, Andhra and the second plant,
id: 4136001, is near Nasik, Maharashtra.

The data were collected at 15 minute intervals for 34 days.

22 inverter sensors and one weather sensor at each plant brought the total to 46
sensors collecting data. 


The inverter sensors collected the DC and AC output of the group of solar panels
it was monitoring.

Additionally, the inverters tallied the daily yield in DC output from
midnight to midnight and maintained the total yield the sensor had observed.

Total yield increased until a sensor was replaced, at which point it would begin
again at 0.


The weather sensors recorded the ambient temperature, the temperature of the
module, and the irradiation level.

Owing to the sensors' reading of 0 at night, it is assumed any irradiation is
owed entirely to the sun's radiation.

## Data Cleaning

### The Raw Data
The data are spread out over four comma separated files, two power generation 
files and two weather sensor files, one each for each plant. 

First, they are read into memory, using lubridate to parse the time stamp,
coercing the plant_id to a character, and renaming variables for usability. 

Note, one of the power generation files has a different date format than the 
other three files. 

This suggests human input or conversion was involved in the collection of
the data.

### Loading the Data
```{r load_data}
parse_generation_data <- function(file_name,
                                  date_format = "ymd HM",
                                  data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    # For some reason, the two files use different date formatting
    mutate(date_time = parse_date_time(DATE_TIME, date_format),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           dc_power = DC_POWER,
           ac_power = AC_POWER,
           daily_yield = DAILY_YIELD,
           total_yield = TOTAL_YIELD) %>%
    relocate(date_time,
             plant_id,
             source_key,
             dc_power,
             ac_power,
             daily_yield,
             total_yield)
}


parse_weather_data <- function(file_name, data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    mutate(date_time = parse_date_time(DATE_TIME, ("ymd HMS")),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           ambient_temperature = AMBIENT_TEMPERATURE,
           module_temperature = MODULE_TEMPERATURE,
           irradiation = IRRADIATION) %>%
    relocate(date_time,
             plant_id,
             source_key,
             ambient_temperature,
             module_temperature,
             irradiation)
}


generation <- 
  parse_generation_data("Plant_1_Generation_Data.csv", "dmy HM") %>%
  bind_rows(parse_generation_data("Plant_2_Generation_Data.csv", "ymd HMS"))

dim(generation)
knitr::kable(head(generation))
```
The generation data consist of 136476 observations of 7 variables: The time stamp,
the plant id number, the inverter key, the measured DC power from the panels, 
the measured AC after inversion, the daily yield of power, and the total yield
that the sensor has ever recorded.
```{r load_weather}
weather <- parse_weather_data("Plant_1_Weather_Sensor_Data.csv") %>%
  bind_rows(parse_weather_data("Plant_2_Weather_Sensor_Data.csv"))

dim(weather)
knitr::kable(head(weather))
```
The weather data consist of only 6441 observations of 6 variables: The time stamp
of the observations at 15 minute intervals, the plant id at which the observation
was taken, the weather sensor key (identical accross the plant), the ambient
temperature in Celsius, the module temperature in Celsius, and the irradiation.

The difference in the number of observations owes to the number of sensors.

Each plant has 22 units recording power generation data, and 1 sensor recording
weather data.
```{r, echo = FALSE}
rm(parse_generation_data, parse_weather_data)
```

### Sanity Checks
First, let us take a look at a summary of the generation data by plant.
```{r plant_summary, echo = FALSE}
generation %>% 
  group_by(plant_id) %>%
  summarize(min_dc = min(dc_power),
            max_dc = max(dc_power),
            median_dc = median(dc_power),
            mean_dc = mean(dc_power)) %>%
  knitr::kable(format = "html",
               caption = "DC Power Summary by Plant")

generation %>%
  group_by(plant_id) %>%
  ggplot(aes(x = dc_power, fill = plant_id))+
  geom_histogram(bins = 20) +
  labs(title = "DC Power Distribution by Plant",
       x = "DC Power",
       y = "Count")
```
The max and mean values are different by about a factor of 10.
By the histogram, it may be seen that the distribution of DC Power observations
is considerably more spread out for plant 4135001 than 4136001.
Over half of the recorded observations at plant 4136001 are 0. 
That is not unreasonable, if we expect the sun to be down for more than half of the day.

However, these data were collected in May in India, which resides in the
Northern hemisphere. 
It would be expected that the sun is out for more than half of the observations.

To better understand what might be happening, let us compare the DC output of
the solar panels to the AC output after conversion.
```{r, echo = FALSE}
generation %>%
  ggplot(aes(x = dc_power, y = ac_power)) +
  geom_point(aes(color = plant_id)) +
  geom_abline(size = 1) +
  labs(title = "DC to AC Power Conversion",
       x = "DC Power",
       y = "AC Power",
       color = "Plant ID") +
  geom_text(aes(0, 1000, label = "y = x"))
```
Plant 4136001 is reporting that the conversion rate from DC power to AC power is
about %100. 
However, 4135001 is reporting a 90% loss of power during conversion, despite
collecting 10 times as much power.

Even the worst DC to AC adapters are about 80% effective. 

This suggests that a conversion error changed the DC Power variable from 
plant 4135001 by a factor of 10.

The conversion error is assumed for the remainder of the analysis, and the 
DC power values for plant 4135001 are divided by 10.

### Missing Observations
As noted previously, there were 136476 power generation observations made.
However, if an observation is made every 15 minutes at 44 sensors for 34 days,
we expect to see
```{r}
60 / 15 *24 * 34 * 44
```
143616 observations. 

The remaining 
```{r}
143616 - 136476
```
7140 observations are missing, and will be considered NA for time series analysis.
Can a pattern to the missing values be found?
To start, we will fill in the missing time values and combine the weather 
data.
```{r join_generation_weather}
join_generation_weather <- function(generation_data, weather_data) {
  generation_data %>%
    group_by(plant_id) %>%
    expand(date_time = full_seq(date_time, as.numeric(minutes(15))), # include a time stamp for every generation source for every 15 minutes
           generation_source = source_key) %>% # rename necessary since weather also has a source_key
    ungroup() %>%
    left_join(generation_data, by = c("date_time", # Add in rows that have been observed
                                 "plant_id", 
                                 "generation_source" = "source_key")) %>% # Rename duplicated variable name
    full_join(weather_data, by = c("date_time", "plant_id")) %>% # Add weather data
    rename(weather_source = source_key) # Rename duplicated variable name
}

solar <- join_generation_weather(generation, weather)
head(solar)
dim(solar)
```
143616 observations of 11 distinct variables, all times are now accounted for.

```{r, echo = FALSE}
solar %>%
  anti_join(generation, by = c("plant_id", "date_time", "generation_source" = "source_key")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(generation$date_time)) +
  labs(title = "Time Series of Power Inverter Failures",
       x = "Time",
       y = "Number of Failures")
```
The above graph shows the number of missing values from power sensors over time.
Notably, missing values at plant 4135001 seem to go across all 22 sensors.
Additionally, For much of the last week of may, plant 4136001 had about 4
power generation sensors that were offline.
```{r, echo = FALSE}
solar %>%
  select(date_time, plant_id) %>%
  unique() %>%
  anti_join(weather, by = c("plant_id", "date_time")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(weather$date_time)) +
  labs(title = "Time Series of Weather Sensor Failures",
       x = "Time",
       y = "Number of Failures")
```
The above graph shows the number of missing values from power sensors over time.
Note that  many of the missing values of one or both weather sensors align with
missing values of the generation sensors as well.
This might suggest maintenance or a failure of a kind that affected the entire plant.

```{r, echo = FALSE}
solar %>%
  na.omit() %>%
  filter((dc_power == 0 & irradiation > 0)) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  labs(title = "Sensor Anomalies Over Time",
       x = "Time", 
       y = "Anamoly Count")
```
The above graph displays anomalies in the sensor data.
Here, an anomaly is defined as an observation in which the irradiation measured
by the weather sensor is greater than 0, but no DC power is generated.
Without more information, it is hard to tell exactly what is happening in these
cases.
For example, is it true that the panels are not actually producing DC power, 
or is it the case simply that the power sensor is not detecting the generated power.
```{r source_na, echo = FALSE}
solar %>%
  group_by(plant_id, generation_source) %>%  
  filter((dc_power == 0 & irradiation > 0) | is.na(dc_power)) %>%
  tally() %>%
  arrange(desc(n)) %>%
  ggplot(aes(x = reorder(generation_source, -n), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Anamolies and Missing Observations by Source",
       x = "Generation Sensor Key",
       y = "Anamoly or Missing Observation Count")
```
It is time to get more granular.
Are there specific sensors that might be contributing disproportionately to missing and anomalous data?
The above graph shows the total number of combined anomalies and missing
observations broken down for each source.
It is clear that plant 4136001 experiences many more problems, with four sources
contributing many problems.
Even the best 4136001 sensor performs worse than the worst 4135001 sensor.
```{r, echo = FALSE}
solar %>%
  na.omit() %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum((dc_power == 0 & irradiation > 0))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Anomaly Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum(is.na(dc_power) | is.na(irradiation))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Failure Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  mutate(is_na = is.na(dc_power) | is.na(irradiation)) %>%
  mutate(likely_na = !is_na & dc_power == 0 & irradiation > 0) %>%
  summarize(na_rate = sum(is_na), likely_na_rate = sum(likely_na)) %>%
  ggplot(aes(x = na_rate, y = likely_na_rate, color = plant_id)) +
  geom_point() +
  labs(title = "Relationship Between Sensor NA and Anamoly",
       x = "NA Count",
       y = "Anamoly County")
```
The prior three graphs separate the combined anamoly counts from the 
missing observation count.
The third graph shows the sensor grouping as a result of relating missing counts
to anamoly counts.
The plant 4136001 cluster shows the healthiest collection of data, while
plant 4135001 clusters suggest that less missing data from a set does not
necessarily mean that the data is more trustworthy.

```{r total_yield}
solar %>%
  filter(plant_id == "4135001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Plant 4135001 Total Yield Over Time",
       x = "Time",
       y = "Total Yield")

solar %>%
  filter(plant_id == "4136001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Plant 4136001 Total Yield Over Time",
       x = "Time",
       y = "Total Yield")
```
For more evidence that plant 4136001 is better left out of model construction,
see the second graph above.
Though it is not clear what might cause these readings from the sensors, it
suggests frequent problems with the sensors.
This, combined with the evidence provided by analyzing the DC power output
of the panels, justifies removal of plant 4136001 from the data set for model
development.

## Data Validation
To best determine the overall efficacy of predictive models, the data sets
were broken into a validation set and a training set.
There were 34 days in the entire data set. 
So, the last three days were partitioned to be a validation set, against
which predictions would only be made after the models were finalized.
Later, to build the models themselves, the training data was separated further 
into a train set and test set, using days 30 - 31 for comparison.

```{r}
date_time_cutoff = make_date(2020, 06, 14)

generation_validation <- generation %>%
  filter(plant_id == "4135001") %>%
  filter(date_time >= date_time_cutoff) %>%
  mutate(dc_power = dc_power / 10)

weather_validation <- generation %>%
  filter(date_time >= date_time_cutoff) %>%
  filter(plant_id == "4135001")

generation_train <- generation %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001") %>%
  mutate(dc_power = dc_power / 10) # Adjust for unit conversion error

weather_train <- weather %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001")

solar <- join_generation_weather(generation_train, weather_train)
```

## Data Exploration
The data has been cleaned.
A validation set has been partitioned.
Before models could be constructed, the data must be further explored to identify
patterns.
### Generation
```{r, echo = FALSe}
generation_train %>%
  select(dc_power, ac_power, daily_yield) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  knitr::kable(caption = "Summary of Power Generation Data")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = dc_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "DC Power Output by Source",
       x = "Source Key",
       y = "DC Power")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = ac_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "AC Power Output by Source",
       x = "Source Key",
       y = "AC Power")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = daily_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Daily Yield by Source",
       x = "Source Key",
       y = "Daily Yield")
```
The above table and box plots show that the power generation across sources
was very consistent, with a few sources showing slight variations.

```{r, echo = FALSE}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Total Yield by Source",
       x = "Source Key",
       y = "Total Yield")

generation_train %>%
  group_by(source_key) %>%
  mutate(total_yield = total_yield - min(total_yield)) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Difference over Month of Total Yield by Source",
       x = "Source Key",
       y = "Difference in Total Yield")
```
Looking at the total yield observed by each source reinforces the view that
each power generator at plant 435001 performed similarly. 
Note that the second graph accounts for the cumulative yield at the start of the
month, thus showing much less variation.
The first graph reveals which of the power generation sensors have been running
the longest.

```{r, echo = FALSE}
# view one day from one source
generation_train %>%
  group_by(source_key) %>%
  filter(date_time < make_date(2020, 05, 16)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = source_key), alpha = 0.5) +
  labs(title = "DC Power Output Over One Day",
       x = "Time",
       y = "DC Power") +
  theme(legend.position = "none")
```
The above graph overlays the DC power output of each generation source during
the first day.
Before sunrise and after sunset, about 5:30 AM and 6:30 PM, no DC power is
is generated.
This is to be expected.
The power output grows, peaks, and drops off.
This is to be expected, if the angle of the sun is expected to impact the solar
panel output.
However, the data is much noisier than to be simply described by the angle of the sun.

Most sources follow similar paths, suggesting a plant-wide variable, like 
irradiation, is a driving force.
However, we also see that one source drops to 0 output around 9:15 AM while the
others only experience a dip.
Sensor faults will have an impact on predictions.

```{r, echo = FALSE}
# view all average for all of month
generation_train %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power)) %>%
  ggplot(aes(x = date_time, y = avg_dc_power)) +
  geom_line() +
  labs(title = "Average DC Power Output Over One Month",
       x = "Time", 
       y = "Average DC Power") +
  theme(legend.position = "none")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = date_time, y = daily_yield, color = source_key)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Daily Yield Over One Month",
       x = "Time",
       y = "Daily Yield")
  
```
The first graph above takes the average dc output of every sensor over the month.
The result is predictably periodic, and peaks at roughly the same value every day.

The second graph shows the cumulative daily yield of each sensor over the month.
This graph more clearly demonstrates the difference in DC output from day to day,
and that each solar power source outputs roughly the same amount every day.

### Weather
```{r, echo = FALSE}
# Ambient Temperature
weather_train %>%
  select(irradiation, module_temperature, ambient_temperature) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  knitr::kable(caption = "Summary of Weather Sensor Data")
```
It is not surprising that the module and ambient temperature have roughly the same
median temperature, 24.7 degrees celsius. However, the module temperature shows
a much greater spread in temperature, especially in higher directions.
The module also gets colder.
This suggests that the module has some sort of cooling system in an attempt to 
mitigate the higher temperatures that it reaches.
The existence of a cooling system suggests that the module has an ideal operating
temperature at which it most efficiently generates power.
The box plot below visualizes the greater spread.

```{r, echo = FALSE}
weather_train %>%
  pivot_longer(cols = c(module_temperature, ambient_temperature), 
               names_pattern = "(.*)_",
               names_to = "sensor",
               values_to = "temperature") %>%
  group_by(sensor) %>%
  ggplot(aes(sensor, temperature)) +
  geom_boxplot() +
  labs(title = "Temperature Readings",
       x = "Sensor",
       y = "Temperature")
```

```{r, echo = FALSE}
weather_train %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(title = "Irradiation Distribution",
       x = "Irradiation",
       y = "Count")

weather_train %>%
  filter(irradiation > 0) %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(title = "Irradiation Distribution (Excluding Nighttimes)",
       x = "Irradiation",
       y = "Count")
```

The first distribution above does not reveal much information.
It is not surprising that the most common observed irradiation is 0, as whenever
the sun is down, the measured irradiation ought to be 0.

The second graph, in which nighttime observations have been removed, reveals an
interesting quirk.
There is a secondary mode for irradiation at about 0.5.
This may have to do with the atmosphere sunlight passes through before reaching
the solar panels.
At certain angles, enough sunlight is scattered that the irradiation remains low.
Once the angle of reflection has been breached, irradiation increases as the angle
of the sunlight approaches normal, or 90 degrees.
Regardless, this graph reveals there is more to the irradiation reaching the solar
panels than simple geometry.

```{r, echo = FALSE}
weather_train %>%
  ggplot(aes(x = date_time, y = irradiation, fill = plant_id)) +
  geom_line() +
  labs(title = "Irradiation Over Time",
       x = "Time",
       y = "Irradiation")

weather_train %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = module_temperature, color = "Module")) +
  geom_line(aes(y = ambient_temperature, color = "Ambient")) +
  labs(title = "Temperature Over Time",
       x = "Time",
       y = "Temperature (Celsius)") +
  guides(color = guide_legend(title = "Sensor"))
```
The irradiation over time follows a pattern that looks very similar to the 
graph generated of dc power output over time.
It is periodic, with a frequency of 1 day.

The temperature data also follows what might be expected after seeing the summary
table.
The module temperature varies much more than the ambient temperature.
However, note that the ambient temperature actually lags behind the module
temperature.
The relationship between irradiation and temperatures will be further examined below.

```{r, echo = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = irradiation, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Irradiation Over a Day",
       x = "Time",
       y = "Irradiation")

weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = module_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Module Temperature Over the Day",
       x = "Time",
       y = "Module Temperature (Celsius)")

weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = ambient_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Ambient Temperature Over the Day",
       x = "Time",
       y = "Ambient Temperature (Celsius)")
```
Irradiation appears to be very noisy.
Yet it is enveloped by a parabola that represents the maximum light from
the sun reaching the solar panel.
The module temperature 
Ambient: Trends DOWN from may to june

```{r, echo = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  summarize(avg_irradiation = mean(irradiation) * 40 + 20,
            avg_module_temperature = mean(module_temperature),
            avg_ambient_temperature = mean(ambient_temperature)) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = avg_irradiation, color = "Irradiation X 40 + 20")) +
  geom_line(aes(y = avg_module_temperature, color = "Module Temperature")) +
  geom_line(aes(y = avg_ambient_temperature, color = "Ambient Temperature")) +
  labs(title = "Averaged Weather Data",
       x = "Time of Day",
       y = "Temperature") +
  guides(color = guide_legend(title = "Average"))
```
Irradiation leads module temperature by about 15 minutes and ambient temperature
by a number of hours.
However, the module temperature appears to be some composition of the ambient
temperature and irradiation.
This might suggest that the weather data can largely be described by the 
irradiation, or by the irradiation and the ambient temperature.

## Correlation
```{r power_correlation}
solar %>%
  na.omit() %>%
  select(dc_power, ac_power) %>%
  cor() %>%
  .[1, 2]
```
The relationship between the DC Power and AC Power produced are highly correlated.

This aligns with expectations, that a certain percent of power is lost in
during conversion.
```{r}
fit <- solar %>%
  lm(ac_power ~ dc_power, data = .)

fit %>%
  tidy() %>%
  knitr::kable()

solar %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point(alpha = 0.25) +
  geom_abline(slope = fit$coefficients[2], intercept = fit$coefficients[1], size = 1) +
  labs(title = "AC Power Produced per DC Power In",
       x = "DC Power",
       y = "AC Power")
```
This fit suggests a 97.7% conversion rate from DC to AC power, only 2.3% is lost. 
This suggests that the plants are using high quality transformers.

### Lag
While exploring the weather data, a lag was noted between irradidation, module
temperature, and ambient temperature.
This could represent some relationship between the three.
Because of the physical properties of temperature and heat flow, it is likely
that irradiation drives both the module temperature and the ambient temperature.
It is unlikely that the module temperature has an effect on the ambient
temperature.
It is possible that the ambient temperature acts as a heat or cold sink for the
module.

For a better understanding of what may be going on with weather at the power
plant, the values of the weather sensors are treated as time series.
```{r irradiation_module_lag}
weather_tsbl <- weather_train %>%
  as_tsibble(index = date_time) %>%
  fill_gaps()

weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(title = "Cross Correlation Between Irradiation and Module Temperature",
       x = "Lag",
       y = "Correlation")

weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  slice_max(ccf)
```

```{r irradiation_ambient_lag}
weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 10) %>%
  autoplot()

weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 48) %>%
  slice_max(ccf)
```

```{r temperature_lags} 
weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 10) %>%
  autoplot()

weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 48) %>%
  slice_max(ccf)
```



## The Model


### Splitting the Train and Test Sets
```{r}
test_set <- solar %>%
  filter(date_time > make_date(2020, 06, 12))

train_set <- solar %>%
  anti_join(test_set)
```


### Baseline (Naive RMSE)
```{r}
mu_hat <- mean(train_set$dc_power, na.rm = TRUE) # 321.0874
naive_rmse <- RMSE(mu_hat, test_set$dc_power) # 401.8058
results <- tibble(method = "Average", RMSE = naive_rmse)
```


### Generation Source Effect
```{r}
average_source <- train_set %>%
  group_by(generation_source) %>%
  summarize(avg_dc_power = mu_hat - mean(dc_power, na.rm = TRUE))

predicted_power <- average_source %>%
  right_join(test_set) %>%
  pull(avg_dc_power)
predicted_power <- predicted_power + mu_hat

average_source_RMSE <- RMSE(predicted_power, test_set$dc_power)
results <- tibble(method = "Average by Source", RMSE = average_source_RMSE)
```


### Irradiation Effect
```{r}
fit <- lm(dc_power ~ irradiation, data = train_set)

train_set %>%
  ggplot(aes(irradiation, dc_power, color = plant_id)) +
  geom_point(alpha = 0.1) +
  geom_abline(slope = fit$coefficients[2],
              intercept = fit$coefficients[1],
              size = 1)
  
predicted_power <- predict(fit, newdata = test_set)

irradiation_rmse <- RMSE(predicted_power, test_set$dc_power) # 583.1007
results <- results %>%
  add_row(method = "Irradiation Effect", RMSE = irradiation_rmse)
```


### Module Temperature Effect
```{r}
train_set %>%
  mutate(dc_power_resid = dc_power - irradiation * fit$coefficients[2] - fit$coefficients[1]) %>%
  ggplot(aes(module_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "black") +
  labs(title = "Module Temperature Effect",
       x = "Module Temperature",
       y = "DC Power Residual")
```
Suggests an optimal operating temperature between 20 and 54 degrees.
Module temperature best represented by parabola

```{r}
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)

irradiation_module_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 40.03656

results <- results %>%
  add_row(method = "Irradiation + Module Temperature Effect", 
          RMSE = irradiation_module_temperature_rmse)
```


### Ambient Temperature Effect
```{r, echo = FALSE}
train_set %>%
  mutate(dc_power_resid = dc_power 
         - fit$coefficients[1] 
         - irradiation * fit$coefficients[2] 
         - module_temperature * fit$coefficients[3]
         - module_temperature ^ 2 * fit$coefficients[4]) %>%
  ggplot(aes(ambient_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.01) +
  geom_smooth(color = "black") +
  labs(title = "Ambient Temperature Effect",
       x = "Ambient Temperature",
       y = "DC Power Residual")
```
This shows a negligible effect.


### ARIMA
Auto-Regressive Integrated Moving Average
```{r}
test_date_times <- test_set %>%
  pull(date_time) %>%
  unique()

generation_sources <- test_set %>%
  pull(generation_source) %>%
  unique()

arima_result <- train_set %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power, na.rm = TRUE)) %>%
  pull(avg_dc_power) %>%
  ts(frequency = 96)  %>% # 4 * 24 for every 15 minutes over 24 hours
  auto.arima(seasonal = TRUE)

arima_result
  
forecast_result <- arima_result %>%
  forecast(h = length(test_date_times)) %>%
  plot()

predicted_power <- tibble(date_time = test_date_times, pred = forecast_result$mean)
predicted_power <- expand_grid(date_time = test_date_times,
                               generation_source = generation_sources) %>%
  left_join(predicted_power, by = "date_time")

arima_rmse <- RMSE(predicted_power$pred, test_set$dc_power) # 179.0664
results <- results %>%
  add_row(method = "ARIMA", RMSE = arima_rmse)
```


### ARIMA By Generation Source
```{r}
ts_train_set <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)
  
arima_models <- ts_train_set %>%
  model(arima = ARIMA(dc_power ~ irradiation + module_temperature + module_temperature_sq))

ts_test_set <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)

predicted_power <- forecast(arima_models, new_data = ts_test_set) %>%
  arrange(date_time) %>%
  pull(.mean)

arima_source_rmse <- RMSE(predicted_power, test_set$dc_power)
results <- results %>%
  add_row(method = "ARIMA by Source", RMSE = arima_source_RMSE)
```


### Random Forest
```{r}
train_set_wide <- train_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = as.factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

test_set_wide <- test_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

fit <- randomForest(dc_power ~ .,
             data = train_set_wide,
             xtest = select(test_set_wide, -dc_power),
             ytest = pull(test_set_wide, dc_power),
             na.action = na.omit)
```


### PCA
Principle Component Analysis
```{r}
result <- prcomp(train_set_wide, scale = TRUE)
result$rotation <- -1 * result$rotation
result$rotation

var_explained <- result$sdev ^ 2 / sum(result$sdev ^ 2) # suggests there is 1 big component, 4 smaller ones of about equal impact
qplot(c(1:7), var_explained) + 
  geom_line()


set.seed(1)
fit <- pcr(dc_power ~ ., data = train_set_wide, scale = TRUE, validation = "CV")
summary(fit)
```

```{r}
RMSEs <- sapply(c(1:6), function(n_comp){
  predicted_power<- predict(fit, test_set_wide, ncomp = n_comp)
  RMSE(predicted_power, test_set$dc_power)
})
qplot(c(1:6), RMSEs) +
  geom_line()
RMSEs
```

### Clamping and Sensor Faults

# Results


## Model Root Mean Squared Errors


## Final Validation


# Conclusion

