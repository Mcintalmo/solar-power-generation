---
title: "solar-plant-power-generation"
author: "Alexander McIntosh"
date: "7/15/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE, # Default to false considering I hope to use mostly graphs
  message = FALSE,
  warning = FALSE,
  tidy = TRUE,
  cahe = TRUE, # Set to FALSE to conserve memory
  eval = TRUE # Set to TRUE for code to actually rune
)
options(digits = 3)
```

# Introduction

As the unintended consequences of traditional energy collection become untenable,
the world is turning to alternative, renewable energy sources.
Solar power has become a particularly popular method of energy extraction.
However, a notable drawback of solar power is its lack of day-to-day consistency.
Inconsistency is a significant challenge for interfacing with an external power grid.

In the analysis to follow, using only the data collected at the solar power plant,
the power output of the plant will be predicted based only on data available to
the plant.
First, suspicious data are examined for usability.
Then, the clean data are explored for patterns, correlation, and causality. 
Finally, four models are engineered using linear regression, ARIMA, random forest
machine learning, and dimension reduction through principle component analysis.
The success of each model is measured by the model's ability to predict three
days worth of data, separated before the models' construction.

For brevity and readability, many of the transformations used on the data to 
produce graphs are not included in this report.
For more information about how the graphs and results were generated,
see <http://www.github.com/mcintalmo/solar-plant-power-generation> . 
The link includes the R Markdown that generated this report and the 
notebook used for exploration.

To explore the raw data, see
*Solar Power Generation Data* from user Ani Kanal on Kaggle. 
<https://www.kaggle.com/datasets/ef9660b4985471a8797501c8970009f36c5b3515213e2676cf40f540f0100e54> 
Or use command 
```
kaggle datasets download -d anikannal/solar-power-generation-data
```

# Methods and Analysis

This analysis was conducted entirely within R. 
Packages included tidyverse and broom for data organization and transformation.
Lubridate and hms allowed for time stamp transformation.
Tsibble, forecast, fable, and feasts provided the backbone of analysis of the data as a 
time series and use of the ARIMA model.
Ranger, randomForest, pls, and caret all contributed functions for developing
a machine learning model.
kableExtra was used only in this report to generate more visually appealing tables.

```{r packages, echo = FALSE}
library(tidyverse)
library(broom)
library(lubridate)
library(hms)
library(tsibble)
library(forecast)
library(feasts)
library(fable) # Requires installing "feasts" package
library(ranger)
library(randomForest)
library(pls)
library(caret)
library(kableExtra)
```
## Data Collection
The data for this analysis was collected by two solar plants in India.
The first plant, id: 4135001, is near Gandikotta, Andhra and the second plant,
id: 4136001, is near Nasik, Maharashtra.
The data were collected at 15 minute intervals for 34 days.
22 inverter sensors and one weather sensor at each plant brought the total to 46
sensors collecting data. 


The inverter sensors collected the DC and AC output of the group of solar panels
it was monitoring.
Additionally, the inverters tallied the daily yield in DC output from
midnight to midnight and maintained the total yield the sensor had observed.
Total yield increased until a sensor was replaced, at which point it would begin
again at 0.


The weather sensors recorded the ambient temperature, the temperature of the
module, and the irradiation level.
Owing to the sensors' reading of 0 at night, it is assumed any irradiation is
owed entirely to the sun's radiation.

## Data Cleaning

### The Raw Data
The data are spread out over four comma separated files; two power generation 
files and two weather sensor files, one each for each plant. 
First, the data are read into memory, using lubridate to parse the time stamp,
coercing the plant_id to a character, and renaming variables for usability. 
Note, one of the power generation files has a different date format than the 
other three files. 
This suggests human input or conversion was involved in the collection of
the data.

### Loading the Data
```{r load_data}
parse_generation_data <- function(file_name,
                                  date_format = "ymd HM",
                                  data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    # For some reason, the two files use different date formatting
    mutate(date_time = parse_date_time(DATE_TIME, date_format),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           dc_power = DC_POWER,
           ac_power = AC_POWER,
           daily_yield = DAILY_YIELD,
           total_yield = TOTAL_YIELD) %>%
    relocate(date_time,
             plant_id,
             source_key,
             dc_power,
             ac_power,
             daily_yield,
             total_yield)
}


parse_weather_data <- function(file_name, data_path = "./data/") {
  read.csv(paste0(data_path, file_name)) %>%
    as_tibble() %>%
    mutate(date_time = parse_date_time(DATE_TIME, ("ymd HMS")),
           plant_id = as.character(PLANT_ID)) %>%
    select(-DATE_TIME, -PLANT_ID) %>%
    rename(source_key = SOURCE_KEY,
           ambient_temperature = AMBIENT_TEMPERATURE,
           module_temperature = MODULE_TEMPERATURE,
           irradiation = IRRADIATION) %>%
    relocate(date_time,
             plant_id,
             source_key,
             ambient_temperature,
             module_temperature,
             irradiation)
}


generation <- 
  parse_generation_data("Plant_1_Generation_Data.csv", "dmy HM") %>%
  bind_rows(parse_generation_data("Plant_2_Generation_Data.csv", "ymd HMS"))

dim(generation)
head(generation) %>%
  kbl() %>%
  kable_material()
generation %>%
  select(plant_id, source_key) %>%
  group_by(source_key) %>%
  slice(1) %>%
  pivot_wider(names_from = "plant_id", values_from = "source_key") %>%
  unnest() %>%
  kbl() %>%
  kable_material()
```
The generation data consist of 136476 observations of 7 variables: The time stamp,
the plant id number, the inverter key, the measured DC power from the panels, 
the measured AC after inversion, the daily yield of power, and the total yield
that the sensor has ever recorded.
```{r load_weather}
weather <- parse_weather_data("Plant_1_Weather_Sensor_Data.csv") %>%
  bind_rows(parse_weather_data("Plant_2_Weather_Sensor_Data.csv"))

dim(weather)
head(weather) %>% 
  kbl() %>%
  kable_material()
weather %>%
  select(plant_id, source_key) %>%
  group_by(source_key) %>%
  slice(1) %>%
  pivot_wider(names_from = "plant_id", values_from = "source_key") %>%
  unnest() %>%
  kbl() %>%
  kable_material()
```
The weather data consist of only 6441 observations of 6 variables: The time stamp
of the observations at 15 minute intervals, the plant id at which the observation
was taken, the weather sensor key (identical accross the plant), the ambient
temperature in Celsius, the module temperature in Celsius, and the irradiation.
The difference in the number of observations owes to the number of sensors.
Each plant has 22 units recording power generation data, and 1 sensor recording
weather data.
```{r, echo = FALSE}
rm(parse_generation_data, parse_weather_data)
```

### Sanity Checks
First, let us take a look at a summary of the generation data by plant.
```{r plant_summary, echo = FALSE}
generation %>% 
  group_by(plant_id) %>%
  summarize(min_dc = min(dc_power),
            max_dc = max(dc_power),
            median_dc = median(dc_power),
            mean_dc = mean(dc_power)) %>%
  kbl(caption = "DC Ppower Summary by Plant") %>%
  kable_material()

generation %>%
  group_by(plant_id) %>%
  ggplot(aes(x = dc_power, fill = plant_id))+
  geom_histogram(bins = 20) +
  labs(title = "DC Power Distribution by Plant",
       x = "DC Power",
       y = "Count")
```
The max and mean values are different by about a factor of 10.
By the histogram, it may be seen that the distribution of DC Power observations
is considerably more spread out for plant 4135001 than 4136001.
Over half of the recorded observations at plant 4136001 are 0. 
That is not unreasonable, if we expect the sun to be down for more than half of the day.

However, these data were collected in May in India, which resides in the
Northern hemisphere. 
It would be expected that the sun is out for more than half of the observations.

To better understand what might be happening, let us compare the DC output of
the solar panels to the AC output after conversion.
```{r, echo = FALSE}
generation %>%
  ggplot(aes(x = dc_power, y = ac_power)) +
  geom_point(aes(color = plant_id)) +
  geom_abline(size = 1) +
  labs(title = "DC to AC Power Conversion",
       x = "DC Power",
       y = "AC Power",
       color = "Plant ID") +
  geom_text(aes(0, 1000, label = "y = x"))
```
Plant 4136001 is reporting that the conversion rate from DC power to AC power is
about %100. 
However, 4135001 is reporting a 90% loss of power during conversion, despite
collecting 10 times as much power.

Even the worst DC to AC adapters are about 80% effective. 

This suggests that a conversion error changed the DC Power variable from 
plant 4135001 by a factor of 10.

The conversion error is assumed for the remainder of the analysis, and the 
DC power values for plant 4135001 are divided by 10.

### Missing Observations
As noted previously, there were 136476 power generation observations made.
However, if an observation is made every 15 minutes at 44 sensors for 34 days,
we expect to see
```{r}
60 / 15 *24 * 34 * 44
```
143616 observations. 

The remaining 
```{r}
143616 - 136476
```
7140 observations are missing, and will be considered NA for time series analysis.
Can a pattern to the missing values be found?
To start, we will fill in the missing time values and combine the weather 
data.
```{r join_generation_weather}
join_generation_weather <- function(generation_data, weather_data) {
  generation_data %>%
    group_by(plant_id) %>%
    expand(date_time = full_seq(date_time, as.numeric(minutes(15))), # include a time stamp for every generation source for every 15 minutes
           generation_source = source_key) %>% # rename necessary since weather also has a source_key
    ungroup() %>%
    left_join(generation_data, by = c("date_time", # Add in rows that have been observed
                                 "plant_id", 
                                 "generation_source" = "source_key")) %>% # Rename duplicated variable name
    full_join(weather_data, by = c("date_time", "plant_id")) %>% # Add weather data
    rename(weather_source = source_key) # Rename duplicated variable name
}

solar <- join_generation_weather(generation, weather)
head(solar) %>%
  kbl() %>%
  kable_material()
dim(solar)
```
143616 observations of 11 distinct variables, all times are now accounted for.

```{r, echo = FALSE}
solar %>%
  anti_join(generation, by = c("plant_id", "date_time", "generation_source" = "source_key")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(generation$date_time)) +
  labs(title = "Time Series of Power Inverter Failures",
       x = "Time",
       y = "Number of Failures")
```
The above graph shows the number of missing values from power sensors over time.
Notably, missing values at plant 4135001 seem to go across all 22 sensors.
Additionally, For much of the last week of may, plant 4136001 had about 4
power generation sensors that were offline.
```{r, echo = FALSE}
solar %>%
  select(date_time, plant_id) %>%
  unique() %>%
  anti_join(weather, by = c("plant_id", "date_time")) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  xlim(range(weather$date_time)) +
  labs(title = "Time Series of Weather Sensor Failures",
       x = "Time",
       y = "Number of Failures")
```
The above graph shows the number of missing values from power sensors over time.
Note that  many of the missing values of one or both weather sensors align with
missing values of the generation sensors as well.
This might suggest maintenance or a failure of a kind that affected the entire plant.

```{r, echo = FALSE}
solar %>%
  na.omit() %>%
  filter((dc_power == 0 & irradiation > 0)) %>%
  ggplot(aes(x = date_time, fill = plant_id, color = plant_id)) +
  geom_bar() +
  labs(title = "Sensor Anomalies Over Time",
       x = "Time", 
       y = "Anamoly Count")
```
The above graph displays anomalies in the sensor data.
Here, an anomaly is defined as an observation in which the irradiation measured
by the weather sensor is greater than 0, but no DC power is generated.
Without more information, it is hard to tell exactly what is happening in these
cases.
For example, is it true that the panels are not actually producing DC power, 
or is it the case simply that the power sensor is not detecting the generated power.
```{r source_na, echo = FALSE}
solar %>%
  group_by(plant_id, generation_source) %>%  
  filter((dc_power == 0 & irradiation > 0) | is.na(dc_power)) %>%
  tally() %>%
  arrange(desc(n)) %>%
  ggplot(aes(x = reorder(generation_source, -n), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Anamolies and Missing Observations by Source",
       x = "Generation Sensor Key",
       y = "Anamoly or Missing Observation Count")
```
It is time to get more granular.
Are there specific sensors that might be contributing disproportionately to missing and anomalous data?
The above graph shows the total number of combined anomalies and missing
observations broken down for each source.
It is clear that plant 4136001 experiences many more problems, with four sources
contributing many problems.
Even the best 4136001 sensor performs worse than the worst 4135001 sensor.
```{r, echo = FALSE}
solar %>%
  na.omit() %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum((dc_power == 0 & irradiation > 0))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Anomaly Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  summarize(n = sum(is.na(dc_power) | is.na(irradiation))) %>%
  ggplot(aes(x = reorder(generation_source, desc(n)), y = n, fill = plant_id)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Combined Sensor Failure Count Per Sensor",
       x = "Generation Source Key",
       y = "Count")

solar %>%
  group_by(plant_id, generation_source) %>%
  mutate(is_na = is.na(dc_power) | is.na(irradiation)) %>%
  mutate(likely_na = !is_na & dc_power == 0 & irradiation > 0) %>%
  summarize(na_rate = sum(is_na), likely_na_rate = sum(likely_na)) %>%
  ggplot(aes(x = na_rate, y = likely_na_rate, color = plant_id)) +
  geom_point() +
  labs(title = "Relationship Between Sensor NA and Anamoly",
       x = "NA Count",
       y = "Anamoly County")
```
The prior three graphs separate the combined anamoly counts from the 
missing observation count.
The third graph shows the sensor grouping as a result of relating missing counts
to anamoly counts.
The plant 4136001 cluster shows the healthiest collection of data, while
plant 4135001 clusters suggest that less missing data from a set does not
necessarily mean that the data is more trustworthy.

```{r total_yield}
solar %>%
  filter(plant_id == "4135001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Plant 4135001 Total Yield Over Time",
       x = "Time",
       y = "Total Yield")

solar %>%
  filter(plant_id == "4136001") %>%
  ggplot(aes(x = date_time, y = total_yield, color = generation_source)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Plant 4136001 Total Yield Over Time",
       x = "Time",
       y = "Total Yield")
```
For more evidence that plant 4136001 is better left out of model construction,
see the second graph above.
Though it is not clear what might cause these readings from the sensors, it
suggests frequent problems with the sensors.
This, combined with the evidence provided by analyzing the DC power output
of the panels, justifies removal of plant 4136001 from the data set for model
development.

## Data Validation
To best determine the overall efficacy of predictive models, the data sets
were broken into a validation set and a training set.
There were 34 days in the entire data set. 
So, the last three days were partitioned to be a validation set, against
which predictions would only be made after the models were finalized.
Later, to build the models themselves, the training data was separated further 
into a train set and test set, using days 30 - 31 for comparison.

```{r}
date_time_cutoff = make_date(2020, 06, 14)

generation_validation <- generation %>%
  filter(plant_id == "4135001") %>%
  filter(date_time >= date_time_cutoff) %>%
  mutate(dc_power = dc_power / 10)

weather_validation <- generation %>%
  filter(date_time >= date_time_cutoff) %>%
  filter(plant_id == "4135001")

generation_train <- generation %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001") %>%
  mutate(dc_power = dc_power / 10) # Adjust for unit conversion error

weather_train <- weather %>%
  filter(date_time < date_time_cutoff) %>%
  filter(plant_id == "4135001")

solar <- join_generation_weather(generation_train, weather_train)
```

## Data Exploration
The data has been cleaned.
A validation set has been partitioned.
Before models could be constructed, the data must be further explored to identify
patterns.
### Generation
```{r, echo = FALSE}
generation_train %>%
  select(dc_power, ac_power, daily_yield) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  kbl(caption = "Summary of Power Generation Data") %>%
  kable_material()

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = dc_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "DC Power Output by Source",
       x = "Source Key",
       y = "DC Power")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = ac_power)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "AC Power Output by Source",
       x = "Source Key",
       y = "AC Power")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = daily_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Daily Yield by Source",
       x = "Source Key",
       y = "Daily Yield")
```
The above table and box plots show that the power generation across sources
was very consistent, with a few sources showing slight variations.

```{r, echo = FALSE}
generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Total Yield by Source",
       x = "Source Key",
       y = "Total Yield")

generation_train %>%
  group_by(source_key) %>%
  mutate(total_yield = total_yield - min(total_yield)) %>%
  ggplot(aes(x = source_key, y = total_yield)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "Difference over Month of Total Yield by Source",
       x = "Source Key",
       y = "Difference in Total Yield")
```
Looking at the total yield observed by each source reinforces the view that
each power generator at plant 435001 performed similarly. 
Note that the second graph accounts for the cumulative yield at the start of the
month, thus showing much less variation.
The first graph reveals which of the power generation sensors have been running
the longest.

```{r, echo = FALSE}
# view one day from one source
generation_train %>%
  group_by(source_key) %>%
  filter(date_time < make_date(2020, 05, 16)) %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = dc_power, color = source_key), alpha = 0.5) +
  labs(title = "DC Power Output Over One Day",
       x = "Time",
       y = "DC Power") +
  theme(legend.position = "none")
```
The above graph overlays the DC power output of each generation source during
the first day.
Before sunrise and after sunset, about 5:30 AM and 6:30 PM, no DC power is
is generated.
This is to be expected.
The power output grows, peaks, and drops off.
This is to be expected, if the angle of the sun is expected to impact the solar
panel output.
However, the data is much noisier than to be simply described by the angle of the sun.

Most sources follow similar paths, suggesting a plant-wide variable, like 
irradiation, is a driving force.
However, we also see that one source drops to 0 output around 9:15 AM while the
others only experience a dip.
Sensor faults will have an impact on predictions.

```{r, echo = FALSE}
# view all average for all of month
generation_train %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power)) %>%
  ggplot(aes(x = date_time, y = avg_dc_power)) +
  geom_line() +
  labs(title = "Average DC Power Output Over One Month",
       x = "Time", 
       y = "Average DC Power") +
  theme(legend.position = "none")

generation_train %>%
  group_by(source_key) %>%
  ggplot(aes(x = date_time, y = daily_yield, color = source_key)) +
  geom_line(alpha = 0.25) +
  theme(legend.position = "none") +
  labs(title = "Daily Yield Over One Month",
       x = "Time",
       y = "Daily Yield")
  
```
The first graph above takes the average dc output of every sensor over the month.
The result is predictably periodic, and peaks at roughly the same value every day.

The second graph shows the cumulative daily yield of each sensor over the month.
This graph more clearly demonstrates the difference in DC output from day to day,
and that each solar power source outputs roughly the same amount every day.

### Weather
```{r, echo = FALSE}
# Ambient Temperature
weather_train %>%
  select(irradiation, module_temperature, ambient_temperature) %>%
  summarize_all(list(min = min, max = max, median = median, mean = mean, sd = sd)) %>%
  pivot_longer(cols = everything(),
               names_pattern = "(.*)_(.*)",
               names_to = c("Variable", ".value")) %>%
  kbl(caption = "Summary of Weather Sensor Data") %>%
  kable_material()
```
It is not surprising that the module and ambient temperature have roughly the same
median temperature, 24.7 degrees celsius. However, the module temperature shows
a much greater spread in temperature, especially in higher directions.
The module also gets colder.
This suggests that the module has some sort of cooling system in an attempt to 
mitigate the higher temperatures that it reaches.
The existence of a cooling system suggests that the module has an ideal operating
temperature at which it most efficiently generates power.
The box plot below visualizes the greater spread.

```{r, echo = FALSE}
weather_train %>%
  pivot_longer(cols = c(module_temperature, ambient_temperature), 
               names_pattern = "(.*)_",
               names_to = "sensor",
               values_to = "temperature") %>%
  group_by(sensor) %>%
  ggplot(aes(sensor, temperature)) +
  geom_boxplot() +
  labs(title = "Temperature Readings",
       x = "Sensor",
       y = "Temperature")
```

```{r, echo = FALSE}
weather_train %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(title = "Irradiation Distribution",
       x = "Irradiation",
       y = "Count")

weather_train %>%
  filter(irradiation > 0) %>%
  ggplot(aes(irradiation)) +
  geom_histogram(bins = 25) +
  labs(title = "Irradiation Distribution (Excluding Nighttimes)",
       x = "Irradiation",
       y = "Count")
```

The first distribution above does not reveal much information.
It is not surprising that the most common observed irradiation is 0, as whenever
the sun is down, the measured irradiation ought to be 0.

The second graph, in which nighttime observations have been removed, reveals an
interesting quirk.
There is a secondary mode for irradiation at about 0.5.
This may have to do with the atmosphere sunlight passes through before reaching
the solar panels.
At certain angles, enough sunlight is scattered that the irradiation remains low.
Once the angle of reflection has been breached, irradiation increases as the angle
of the sunlight approaches normal, or 90 degrees.
Regardless, this graph reveals there is more to the irradiation reaching the solar
panels than simple geometry.

```{r, echo = FALSE}
weather_train %>%
  ggplot(aes(x = date_time, y = irradiation, fill = plant_id)) +
  geom_line() +
  labs(title = "Irradiation Over Time",
       x = "Time",
       y = "Irradiation")

weather_train %>%
  ggplot(aes(x = date_time)) +
  geom_line(aes(y = module_temperature, color = "Module")) +
  geom_line(aes(y = ambient_temperature, color = "Ambient")) +
  labs(title = "Temperature Over Time",
       x = "Time",
       y = "Temperature (Celsius)") +
  guides(color = guide_legend(title = "Sensor"))
```
The irradiation over time follows a pattern that looks very similar to the 
graph generated of dc power output over time.
It is periodic, with a frequency of 1 day.

The temperature data also follows what might be expected after seeing the summary
table.
The module temperature varies much more than the ambient temperature.
However, note that the ambient temperature actually lags behind the module
temperature.
The relationship between irradiation and temperatures will be further examined below.

```{r, echo = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = irradiation, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Irradiation Over a Day",
       x = "Time",
       y = "Irradiation")

weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = module_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Module Temperature Over the Day",
       x = "Time",
       y = "Module Temperature (Celsius)")

weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  ggplot(aes(x = time, y = ambient_temperature, group = date, color = date)) +
  geom_line(alpha = 0.25) +
  labs(title = "Ambient Temperature Over the Day",
       x = "Time",
       y = "Ambient Temperature (Celsius)")
```
Irradiation appears to be very noisy.
Yet it is enveloped by a parabola that represents the maximum light from
the sun reaching the solar panel.
The module temperature 
Ambient: Trends DOWN from may to june

```{r, echo = FALSE}
weather_train %>%
  mutate(date = round_date(date_time, unit = "day"),
         time = as_datetime(as_hms(date_time))) %>%
  group_by(time) %>%
  summarize(avg_irradiation = mean(irradiation) * 40 + 20,
            avg_module_temperature = mean(module_temperature),
            avg_ambient_temperature = mean(ambient_temperature)) %>%
  ggplot(aes(x = time)) +
  geom_line(aes(y = avg_irradiation, color = "Irradiation X 40 + 20")) +
  geom_line(aes(y = avg_module_temperature, color = "Module Temperature")) +
  geom_line(aes(y = avg_ambient_temperature, color = "Ambient Temperature")) +
  labs(title = "Averaged Weather Data",
       x = "Time of Day",
       y = "Temperature") +
  guides(color = guide_legend(title = "Average"))
```
Note that in the graph above, the scale of the irradiation has been multiplied 
by 40 and shifted up 20 degrees to better visualize relationships.
Irradiation leads module temperature by about 15 minutes and ambient temperature
by a number of hours.
However, the module temperature appears to be some composition of the ambient
temperature and irradiation.
This might suggest that the weather data can largely be described by the 
irradiation, or by the irradiation and the ambient temperature.

## Correlation
```{r power_correlation}
solar %>%
  na.omit() %>%
  select(dc_power, ac_power) %>%
  cor() %>%
  .[1, 2]
```
The relationship between the DC Power and AC Power produced are highly correlated.

This aligns with expectations, that a certain percent of power is lost in
during conversion.
```{r}
fit <- solar %>%
  lm(ac_power ~ dc_power, data = .)

fit %>%
  tidy() %>%
  kbl(caption = "AC Power per DC Power") %>%
  kable_material()

solar %>%
  ggplot(aes(x = dc_power, y = ac_power, color = plant_id)) +
  geom_point(alpha = 0.25) +
  geom_abline(slope = fit$coefficients[2], intercept = fit$coefficients[1], size = 1) +
  labs(title = "AC Power Produced per DC Power In",
       x = "DC Power",
       y = "AC Power")
```
This fit suggests a 97.7% conversion rate from DC to AC power, only 2.3% is lost. 
This suggests that the plants are using high quality transformers.

### Lag
While exploring the weather data, a lag was noted between irradiation, module
temperature, and ambient temperature.
This could represent some relationship between the three.
Because of the physical properties of temperature and heat flow, it is likely
that irradiation drives both the module temperature and the ambient temperature.
It is unlikely that the module temperature has an effect on the ambient
temperature.
It is possible that the ambient temperature acts as a heat or cold sink for the
module.

For a better understanding of what may be going on with weather at the power
plant, the values of the weather sensors are treated as time series.
```{r irradiation_module_lag}
weather_tsbl <- weather_train %>%
  as_tsibble(index = date_time) %>%
  fill_gaps()

weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(title = "Cross Correlation Between Irradiation and Module Temperature",
       x = "Lag",
       y = "Correlation")

weather_tsbl %>%
  CCF(y = module_temperature, x = irradiation, lag_max = 10) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption = "Lag of Maximum Cross Correlation Between Irradiation and Module Temperature") %>%
  kable_material()
```
A strong correlation is found between the irradiation and the module temperature
after a 15 minute lag.
This can be explained by the radiation heat transfer as a result of the 
electromagnetic radiation of the sun.
It does not take long for higher irradiation to increase the temperature of the module.
However, referring back to the average day temperatures graph, it appears that
as the radiation increases, temperature increases in step.
As the radiation decreases, the temperature decreases after about 30 minutes.

```{r irradiation_ambient_lag}
weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(title = "Cross Correlation Between Irradiation and Ambient Temperature",
       x = "Lag",
       y = "Correlation")

weather_tsbl %>%
  CCF(y = ambient_temperature, x = irradiation, lag_max = 48) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption = "Lag of Maximum Cross Correlation Between Irradiation and Ambient Temperature") %>%
  kable_material()
```
The connection between irradiation and ambient temperature is less clear. 
The correlation of 0.877 after an hour and fifteen minutes suggested that
irradiation has some effect on the ambient temperature.
The increased lag time has to do with how much less interaction there is between
rays from the sun and air molecules vs a stationary module.
However, there are sufficient confounding and unobserved variables related to 
weather and weather prediction that it is beyond the scope of this analysis to dig
deeper.

```{r temperature_lags} 
weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 10) %>%
  ggplot(aes(x = lag, y = ccf)) +
  geom_point() +
  labs(title = "Cross Correlation Between Module Temperature and Ambient Temperature",
       x = "Lag",
       y = "Correlation")

weather_tsbl %>%
  CCF(y = ambient_temperature, x = module_temperature, lag_max = 48) %>%
  slice_max(ccf) %>%
  rename(correlation = ccf) %>%
  kbl(caption = "Lag of Maximum Cross Correlation Between Module Temperature and Ambient Temperature") %>%
  kable_material()
```

Interestingly, the ambient temperature lags the module temperature.
At first glance, this does not make much sense.
It is unlikely that a module can be driving the ambient temperature.

However, if one keeps in mind the confounding variable of weather, the relationship 
between irradiation and module temperature explains this.
It is far more likely that the ambient environment acts as a heat sink when the
module becomes very hot.
Though the physical interactions of heat transfer are modellable, they are
outside the scope of this analysis.


## The Model

### Splitting the Train and Test Sets
A validation data set has already been separated from the data.
However, to evaluate the efficacy of the model as it is constructed, it becomes
necessary to further partition the data to avoid over training.
The final two days of the solar data will be put into a test set, all other data
remain in a train set.
```{r}
test_set <- solar %>%
  filter(date_time > make_date(2020, 06, 12))

train_set <- solar %>%
  anti_join(test_set)
```


### Baseline (Naive RMSE)
As established, the RMSE is the metric by which success is measured.
To get an understanding of how much the model is improving, the naive RMSE will
be calculated as a baseline
That is, the predicted dc_power will simply be the mean of all dc_power observed.

```{r}
mu_hat <- mean(train_set$dc_power, na.rm = TRUE) # 321.0874
naive_rmse <- RMSE(mu_hat, test_set$dc_power) # 401.8058
results <- tibble(method = "Average", RMSE = naive_rmse, improvement = 0)
mu_hat
naive_rmse
```
The average of the dc_power over the entire data set is 321.
Predicting the average dc_power results in an RMSE of 402.
That is substantial.
Time to explore ways to reducing reduce it.


### Generation Source Effect
To start, the effect of stratifying by generation source is examined.
```{r}
average_source <- train_set %>%
  group_by(generation_source) %>%
  summarize(avg_dc_power = mu_hat - mean(dc_power, na.rm = TRUE))

predicted_power <- average_source %>%
  right_join(test_set) %>%
  pull(avg_dc_power) %>%
  + mu_hat

average_by_source_RMSE <- RMSE(predicted_power, test_set$dc_power)
results <- results %>%
  add_row(method = "Average by Source", 
          RMSE = average_by_source_RMSE,
          improvement = (naive_rmse - average_by_source_RMSE) / naive_rmse)
average_by_source_RMSE
```
A slight improvement, but only slight. About a quarter of a percent.

### Irradiation Effect
In exploration, it was observed that irradiation and dc output were highly
correlated.

```{r}
fit <- lm(dc_power ~ irradiation, data = train_set)

train_set %>%
  ggplot(aes(irradiation, dc_power, color = plant_id)) +
  geom_point(alpha = 0.1) +
  geom_abline(slope = fit$coefficients[2],
              intercept = fit$coefficients[1],
              size = 1)
```
The above graph suggests a linear relationship fits rather well.
How much can the RMSE be improved upon using a linear model, using only irradiation
as a predictor?
```{r}
predicted_power <- predict(fit, newdata = test_set)

irradiation_rmse <- RMSE(predicted_power, test_set$dc_power) # 583.1007
results <- results %>%
  add_row(method = "Irradiation Effect", 
          RMSE = irradiation_rmse,
          improvement = (naive_rmse - irradiation_rmse) / naive_rmse)
irradiation_rmse
```
44.4 is, unsurprisingly, a substatial improvement over the naive RMSE.

### Module Temperature Effect
It is not unreasonable to consider other weather effects to construct the model.
```{r}
train_set %>%
  mutate(dc_power_resid = dc_power - irradiation * fit$coefficients[2] - fit$coefficients[1]) %>%
  ggplot(aes(module_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.05) +
  geom_smooth(color = "black") +
  labs(title = "Module Temperature Effect",
       x = "Module Temperature",
       y = "DC Power Residual")
```
The above graph, relating module temperature and the DC power output, suggests 
that the module has an optimal operating temperature between 20 and 54 degrees.
The relationship does not appear to be a straight line, however.
Perhaps the module temperature effect is best represented by parabola

```{r}
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + module_temperature + module_temperature_sq, data = .)


predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)

irradiation_module_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 40.03656

results <- results %>%
  add_row(method = "Irradiation + Module Temperature Effect", 
          RMSE = irradiation_module_temperature_rmse,
          improvement = (naive_rmse - irradiation_module_temperature_rmse) / naive_rmse)
irradiation_module_temperature_rmse
```
40.0, a %9.9 improvement over a purely irradiation effect.

Earlier, it was discovered that module temperature lagged irradiation by 15 minutes
and was highly correlated.
Can a similar RMSE be achieved by simply lagging the irradiation by 15 mintutes?
Note, the lagged time series results in an NA.
Since this is at night, it will be replaced with the lowest predicted dc_power.
```{r}
fit <- train_set %>% 
  mutate(lag_irradiation = lag(irradiation, 1),
         lag_irradiation_sq = lag_irradiation ^2) %>%
  lm(dc_power ~ irradiation + lag_irradiation + lag_irradiation_sq, data = .)

predicted_power <- test_set %>%
  mutate(lag_irradiation = lag(irradiation, 1),
         lag_irradiation_sq = lag_irradiation ^2) %>%
  predict(fit, newdata = .) %>%
  replace_na(min(., na.rm = TRUE))

irradiation_lag_rmse <- RMSE(predicted_power, test_set$dc_power)
results <- results %>%
  add_row(method = "Irradiation + Irradiation Lag Effect", 
          RMSE = irradiation_lag_rmse,
          improvement = (naive_rmse - irradiation_lag_rmse) / naive_rmse)
irradiation_lag_rmse
```
40.61, about %1 worse than if module temperature was incorporated.

### Ambient Temperature Effect
Now, the residual DC power is compared to the ambient temperature.
```{r, echo = FALSE}
train_set %>%
  mutate(dc_power_resid = dc_power 
         - fit$coefficients[1] 
         - irradiation * fit$coefficients[2] 
         - module_temperature * fit$coefficients[3]
         - module_temperature ^ 2 * fit$coefficients[4]) %>%
  ggplot(aes(ambient_temperature, dc_power_resid, color = plant_id)) +
  geom_point(alpha = 0.01) +
  geom_smooth(color = "black") +
  labs(title = "Ambient Temperature Effect",
       x = "Ambient Temperature",
       y = "DC Power Residual")
```
This appears to show a negligible effect.

```{r}
fit <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + 
                 module_temperature + 
                 module_temperature_sq +
                 ambient_temperature, data = .)


predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  predict(fit, newdata = .)

irradiation_module_ambient_temperature_rmse <- 
  RMSE(predicted_power, test_set$dc_power) # 39.86
results <- results %>%
  add_row(method = "Irradiation + Module + Ambient Temperature Effect", 
          RMSE = irradiation_module_ambient_temperature_rmse,
          improvement = (naive_rmse - irradiation_module_ambient_temperature_rmse) / naive_rmse)
```
An improvement of less than half of a percent.

### Clamping and Sensor Faults
Let's take a glance look at how our predictions compare to the test data.
```{r, echo = FALSE}
summary(predicted_power) %>%
  bind_rows(summary(test_set$dc_power)) %>%
  as_tibble() %>%
  add_column(.before = "Min.", DC_Power = c("Predicted", "Test Set")) %>%
  kbl(caption = "Summary of Linear Fit Predictions")
```
Immediately, a source of improvement presents itself.
It is not possible for negative DC power to be produced.

```{r}
predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(pred < 0, 0, pred))
  

clamped_rmse <- 
  RMSE(predicted_power$pred, test_set$dc_power)
results <- results %>%
  add_row(method = "Clamped", 
          RMSE = clamped_rmse,
          improvement = (naive_rmse - clamped_rmse) / naive_rmse)
clamped_rmse # 39.65
```

Other intuitive improvements may be made.
For example, consider the anomalous data found during exploratory analysis.
Do we improve the predictive model if we do not train anamolous data?

```{r}
fit <- train_set %>%
  filter(irradiation > 0 & dc_power > 0) %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  lm(dc_power ~ irradiation + 
                 module_temperature + 
                 module_temperature_sq +
                 ambient_temperature, data = .)

predicted_power <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  mutate(pred = predict(fit, newdata = .)) %>%
  mutate(pred = ifelse(pred < 0 | irradiation == 0, 0, pred)) %>%
  pull(pred)
  

clamped_fixed_rmse <- 
  RMSE(predicted_power, test_set$dc_power)
results <- results %>%
  add_row(method = "Clamped + Anomolies Removed", 
          RMSE = clamped_fixed_rmse,
          improvement = (naive_rmse - clamped_fixed_rmse) / naive_rmse)
clamped_fixed_rmse # 39.15
```

A final RMSE of 39.15 is found with a model based on linear regression and some
cleaning.
39.15 is an improvement of 90.3% over the naive RMSE, a considerable improvement.

### ARIMA
ARIMA stands for Auto-Regressive Integrated Moving Average.
It is a statistical analysis model that uses time series data to predict trends.
Autoregressive: Predicts future values based on past values, regresses on its own lagged values
Integrated: Differences raw observations to make the time series stationary
Moving Average: Smooths out time series data by creating a subset of recent data to use as an average
auto.arima (from forecast) and ARIMA (from fable) automatically determine the p, q, and d parameters,
that is, the parameters used in the autoregression, integration, and the moving average.


```{r}
test_date_times <- test_set %>%
  pull(date_time) %>%
  unique()

generation_sources <- test_set %>%
  pull(generation_source) %>%
  unique()

arima_result <- train_set %>%
  group_by(date_time) %>%
  summarize(avg_dc_power = mean(dc_power, na.rm = TRUE)) %>%
  pull(avg_dc_power) %>%
  ts(frequency = 96)  %>% # 4 * 24 for every 15 minutes over 24 hours
  auto.arima(seasonal = TRUE)

arima_result
  
forecast_result <- arima_result %>%
  forecast(h = length(test_date_times)) %>%
  plot()

predicted_power <- tibble(date_time = test_date_times, pred = forecast_result$mean)
predicted_power <- expand_grid(date_time = test_date_times,
                               generation_source = generation_sources) %>%
  left_join(predicted_power, by = "date_time")

arima_rmse <- RMSE(predicted_power$pred, test_set$dc_power) # 179.0664
results <- results %>%
  add_row(method = "ARIMA", RMSE = arima_rmse)
```


### ARIMA By Generation Source
```{r}
ts_train_set <- train_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)
  
arima_models <- ts_train_set %>%
  model(arima = ARIMA(dc_power ~ irradiation + module_temperature + module_temperature_sq))

ts_test_set <- test_set %>%
  mutate(module_temperature_sq = module_temperature ^ 2) %>%
  as_tsibble(key = generation_source, index = date_time)

predicted_power <- forecast(arima_models, new_data = ts_test_set) %>%
  arrange(date_time) %>%
  pull(.mean)

arima_source_rmse <- RMSE(predicted_power, test_set$dc_power)
results <- results %>%
  add_row(method = "ARIMA by Source", RMSE = arima_source_rmse)
```


### Random Forest
```{r, eval = FALSE}
train_set_wide <- train_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = as.factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

test_set_wide <- test_set %>%
  mutate(day = as.numeric(round_date(date_time, unit = "day") - make_datetime(2020, 05, 15)),
         hour = as.numeric(hour(date_time)),
         minute = as.numeric(minute(date_time)),
         generation_source = factor(generation_source)) %>%
  select(-ac_power, -date_time, -plant_id, -weather_source, -daily_yield, -total_yield) %>%
  relocate(dc_power) %>%
  na.omit()

fit <- randomForest(dc_power ~ .,
             data = train_set_wide,
             xtest = select(test_set_wide, -dc_power),
             ytest = pull(test_set_wide, dc_power),
             na.action = na.omit)
```


### PCA
Principle Component Analysis
```{r, eval = FALSE}
result <- prcomp(train_set_wide, scale = TRUE)
result$rotation <- -1 * result$rotation
result$rotation

var_explained <- result$sdev ^ 2 / sum(result$sdev ^ 2) # suggests there is 1 big component, 4 smaller ones of about equal impact
qplot(c(1:7), var_explained) + 
  geom_line()


set.seed(1)
fit <- pcr(dc_power ~ ., data = train_set_wide, scale = TRUE, validation = "CV")
summary(fit)
```

```{r, eval = FALSE}
RMSEs <- sapply(c(1:6), function(n_comp){
  predicted_power<- predict(fit, test_set_wide, ncomp = n_comp)
  RMSE(predicted_power, test_set$dc_power)
})
qplot(c(1:6), RMSEs) +
  geom_line()
RMSEs
```

# Results
```{r}
results %>%
  kbl() %>%
  kable_material()
```


## Model Root Mean Squared Errors


## Final Validation


# Conclusion

